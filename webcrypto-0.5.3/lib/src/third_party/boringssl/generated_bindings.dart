/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com). */
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to BoringSSL.
class BoringSsl {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  BoringSsl(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  BoringSsl.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ASN1_ITEM_st> _ACCESS_DESCRIPTION_it =
      _lookup<ASN1_ITEM_st>('ACCESS_DESCRIPTION_it');

  ffi.Pointer<ASN1_ITEM_st> get ACCESS_DESCRIPTION_it => _ACCESS_DESCRIPTION_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_ANY_it =
      _lookup<ASN1_ITEM_st>('ASN1_ANY_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_ANY_it => _ASN1_ANY_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_BIT_STRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_BIT_STRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_BIT_STRING_it => _ASN1_BIT_STRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_BMPSTRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_BMPSTRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_BMPSTRING_it => _ASN1_BMPSTRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_BOOLEAN_it =
      _lookup<ASN1_ITEM_st>('ASN1_BOOLEAN_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_BOOLEAN_it => _ASN1_BOOLEAN_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_ENUMERATED_it =
      _lookup<ASN1_ITEM_st>('ASN1_ENUMERATED_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_ENUMERATED_it => _ASN1_ENUMERATED_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_FBOOLEAN_it =
      _lookup<ASN1_ITEM_st>('ASN1_FBOOLEAN_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_FBOOLEAN_it => _ASN1_FBOOLEAN_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_GENERALIZEDTIME_it =
      _lookup<ASN1_ITEM_st>('ASN1_GENERALIZEDTIME_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_GENERALIZEDTIME_it =>
      _ASN1_GENERALIZEDTIME_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_GENERALSTRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_GENERALSTRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_GENERALSTRING_it => _ASN1_GENERALSTRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_IA5STRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_IA5STRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_IA5STRING_it => _ASN1_IA5STRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_INTEGER_it =
      _lookup<ASN1_ITEM_st>('ASN1_INTEGER_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_INTEGER_it => _ASN1_INTEGER_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_NULL_it =
      _lookup<ASN1_ITEM_st>('ASN1_NULL_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_NULL_it => _ASN1_NULL_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_OBJECT_it =
      _lookup<ASN1_ITEM_st>('ASN1_OBJECT_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_OBJECT_it => _ASN1_OBJECT_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_OCTET_STRING_NDEF_it =
      _lookup<ASN1_ITEM_st>('ASN1_OCTET_STRING_NDEF_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_OCTET_STRING_NDEF_it =>
      _ASN1_OCTET_STRING_NDEF_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_OCTET_STRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_OCTET_STRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_OCTET_STRING_it => _ASN1_OCTET_STRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_PRINTABLESTRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_PRINTABLESTRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_PRINTABLESTRING_it =>
      _ASN1_PRINTABLESTRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_PRINTABLE_it =
      _lookup<ASN1_ITEM_st>('ASN1_PRINTABLE_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_PRINTABLE_it => _ASN1_PRINTABLE_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_SEQUENCE_ANY_it =
      _lookup<ASN1_ITEM_st>('ASN1_SEQUENCE_ANY_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_SEQUENCE_ANY_it => _ASN1_SEQUENCE_ANY_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_SEQUENCE_it =
      _lookup<ASN1_ITEM_st>('ASN1_SEQUENCE_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_SEQUENCE_it => _ASN1_SEQUENCE_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_SET_ANY_it =
      _lookup<ASN1_ITEM_st>('ASN1_SET_ANY_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_SET_ANY_it => _ASN1_SET_ANY_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_T61STRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_T61STRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_T61STRING_it => _ASN1_T61STRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_TBOOLEAN_it =
      _lookup<ASN1_ITEM_st>('ASN1_TBOOLEAN_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_TBOOLEAN_it => _ASN1_TBOOLEAN_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_TIME_it =
      _lookup<ASN1_ITEM_st>('ASN1_TIME_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_TIME_it => _ASN1_TIME_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_UNIVERSALSTRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_UNIVERSALSTRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_UNIVERSALSTRING_it =>
      _ASN1_UNIVERSALSTRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_UTCTIME_it =
      _lookup<ASN1_ITEM_st>('ASN1_UTCTIME_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_UTCTIME_it => _ASN1_UTCTIME_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_UTF8STRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_UTF8STRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_UTF8STRING_it => _ASN1_UTF8STRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _ASN1_VISIBLESTRING_it =
      _lookup<ASN1_ITEM_st>('ASN1_VISIBLESTRING_it');

  ffi.Pointer<ASN1_ITEM_st> get ASN1_VISIBLESTRING_it => _ASN1_VISIBLESTRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _AUTHORITY_INFO_ACCESS_it =
      _lookup<ASN1_ITEM_st>('AUTHORITY_INFO_ACCESS_it');

  ffi.Pointer<ASN1_ITEM_st> get AUTHORITY_INFO_ACCESS_it =>
      _AUTHORITY_INFO_ACCESS_it;

  late final ffi.Pointer<ASN1_ITEM_st> _AUTHORITY_KEYID_it =
      _lookup<ASN1_ITEM_st>('AUTHORITY_KEYID_it');

  ffi.Pointer<ASN1_ITEM_st> get AUTHORITY_KEYID_it => _AUTHORITY_KEYID_it;

  late final ffi.Pointer<ASN1_ITEM_st> _BASIC_CONSTRAINTS_it =
      _lookup<ASN1_ITEM_st>('BASIC_CONSTRAINTS_it');

  ffi.Pointer<ASN1_ITEM_st> get BASIC_CONSTRAINTS_it => _BASIC_CONSTRAINTS_it;

  /// BN_add sets |r| = |a| + |b|, where |r| may be the same pointer as either |a|
  /// or |b|. It returns one on success and zero on allocation failure.
  int BN_add(
    ffi.Pointer<BIGNUM> r,
    ffi.Pointer<BIGNUM> a,
    ffi.Pointer<BIGNUM> b,
  ) {
    return _BN_add(
      r,
      a,
      b,
    );
  }

  late final _BN_add_ptr = _lookup<ffi.NativeFunction<_c_BN_add>>('BN_add');
  late final _dart_BN_add _BN_add = _BN_add_ptr.asFunction<_dart_BN_add>();

  /// BN_bin2bn sets |*ret| to the value of |len| bytes from |in|, interpreted as
  /// a big-endian number, and returns |ret|. If |ret| is NULL then a fresh
  /// |BIGNUM| is allocated and returned. It returns NULL on allocation
  /// failure.
  ffi.Pointer<BIGNUM> BN_bin2bn(
    ffi.Pointer<ffi.Uint8> in_1,
    int len,
    ffi.Pointer<BIGNUM> ret,
  ) {
    return _BN_bin2bn(
      in_1,
      len,
      ret,
    );
  }

  late final _BN_bin2bn_ptr =
      _lookup<ffi.NativeFunction<_c_BN_bin2bn>>('BN_bin2bn');
  late final _dart_BN_bin2bn _BN_bin2bn =
      _BN_bin2bn_ptr.asFunction<_dart_BN_bin2bn>();

  /// BN_bn2bin_padded serialises the absolute value of |in| to |out| as a
  /// big-endian integer. The integer is padded with leading zeros up to size
  /// |len|. If |len| is smaller than |BN_num_bytes|, the function fails and
  /// returns 0. Otherwise, it returns 1.
  int BN_bn2bin_padded(
    ffi.Pointer<ffi.Uint8> out,
    int len,
    ffi.Pointer<BIGNUM> in_1,
  ) {
    return _BN_bn2bin_padded(
      out,
      len,
      in_1,
    );
  }

  late final _BN_bn2bin_padded_ptr =
      _lookup<ffi.NativeFunction<_c_BN_bn2bin_padded>>('BN_bn2bin_padded');
  late final _dart_BN_bn2bin_padded _BN_bn2bin_padded =
      _BN_bn2bin_padded_ptr.asFunction<_dart_BN_bn2bin_padded>();

  /// BN_cmp returns a value less than, equal to or greater than zero if |a| is
  /// less than, equal to or greater than |b|, respectively.
  int BN_cmp(
    ffi.Pointer<BIGNUM> a,
    ffi.Pointer<BIGNUM> b,
  ) {
    return _BN_cmp(
      a,
      b,
    );
  }

  late final _BN_cmp_ptr = _lookup<ffi.NativeFunction<_c_BN_cmp>>('BN_cmp');
  late final _dart_BN_cmp _BN_cmp = _BN_cmp_ptr.asFunction<_dart_BN_cmp>();

  /// BN_free frees the data referenced by |bn| and, if |bn| was originally
  /// allocated on the heap, frees |bn| also.
  void BN_free(
    ffi.Pointer<BIGNUM> bn,
  ) {
    return _BN_free(
      bn,
    );
  }

  late final _BN_free_ptr = _lookup<ffi.NativeFunction<_c_BN_free>>('BN_free');
  late final _dart_BN_free _BN_free = _BN_free_ptr.asFunction<_dart_BN_free>();

  /// BN_lshift sets |r| equal to |a| << n. The |a| and |r| arguments may be the
  /// same |BIGNUM|. It returns one on success and zero on allocation failure.
  int BN_lshift(
    ffi.Pointer<BIGNUM> r,
    ffi.Pointer<BIGNUM> a,
    int n,
  ) {
    return _BN_lshift(
      r,
      a,
      n,
    );
  }

  late final _BN_lshift_ptr =
      _lookup<ffi.NativeFunction<_c_BN_lshift>>('BN_lshift');
  late final _dart_BN_lshift _BN_lshift =
      _BN_lshift_ptr.asFunction<_dart_BN_lshift>();

  /// BN_new creates a new, allocated BIGNUM and initialises it.
  ffi.Pointer<BIGNUM> BN_new() {
    return _BN_new();
  }

  late final _BN_new_ptr = _lookup<ffi.NativeFunction<_c_BN_new>>('BN_new');
  late final _dart_BN_new _BN_new = _BN_new_ptr.asFunction<_dart_BN_new>();

  /// BN_num_bytes returns the minimum number of bytes needed to represent the
  /// absolute value of |bn|.
  int BN_num_bytes(
    ffi.Pointer<BIGNUM> bn,
  ) {
    return _BN_num_bytes(
      bn,
    );
  }

  late final _BN_num_bytes_ptr =
      _lookup<ffi.NativeFunction<_c_BN_num_bytes>>('BN_num_bytes');
  late final _dart_BN_num_bytes _BN_num_bytes =
      _BN_num_bytes_ptr.asFunction<_dart_BN_num_bytes>();

  /// BN_set_word sets |bn| to |value|. It returns one on success or zero on
  /// allocation failure.
  int BN_set_word(
    ffi.Pointer<BIGNUM> bn,
    int value,
  ) {
    return _BN_set_word(
      bn,
      value,
    );
  }

  late final _BN_set_word_ptr =
      _lookup<ffi.NativeFunction<_c_BN_set_word>>('BN_set_word');
  late final _dart_BN_set_word _BN_set_word =
      _BN_set_word_ptr.asFunction<_dart_BN_set_word>();

  /// BN_sub sets |r| = |a| - |b|, where |r| may be the same pointer as either |a|
  /// or |b|. It returns one on success and zero on allocation failure.
  int BN_sub(
    ffi.Pointer<BIGNUM> r,
    ffi.Pointer<BIGNUM> a,
    ffi.Pointer<BIGNUM> b,
  ) {
    return _BN_sub(
      r,
      a,
      b,
    );
  }

  late final _BN_sub_ptr = _lookup<ffi.NativeFunction<_c_BN_sub>>('BN_sub');
  late final _dart_BN_sub _BN_sub = _BN_sub_ptr.asFunction<_dart_BN_sub>();

  /// BN_value_one returns a static BIGNUM with value 1.
  ffi.Pointer<BIGNUM> BN_value_one() {
    return _BN_value_one();
  }

  late final _BN_value_one_ptr =
      _lookup<ffi.NativeFunction<_c_BN_value_one>>('BN_value_one');
  late final _dart_BN_value_one _BN_value_one =
      _BN_value_one_ptr.asFunction<_dart_BN_value_one>();

  /// BORINGSSL_self_test triggers the FIPS KAT-based self tests. It returns one on
  /// success and zero on error.
  int BORINGSSL_self_test() {
    return _BORINGSSL_self_test();
  }

  late final _BORINGSSL_self_test_ptr =
      _lookup<ffi.NativeFunction<_c_BORINGSSL_self_test>>(
          'BORINGSSL_self_test');
  late final _dart_BORINGSSL_self_test _BORINGSSL_self_test =
      _BORINGSSL_self_test_ptr.asFunction<_dart_BORINGSSL_self_test>();

  /// CBB_cleanup frees all resources owned by |cbb| and other |CBB| objects
  /// writing to the same buffer. This should be used in an error case where a
  /// serialisation is abandoned.
  ///
  /// This function can only be called on a "top level" |CBB|, i.e. one initialised
  /// with |CBB_init| or |CBB_init_fixed|, or a |CBB| set to the zero state with
  /// |CBB_zero|.
  void CBB_cleanup(
    ffi.Pointer<CBB> cbb,
  ) {
    return _CBB_cleanup(
      cbb,
    );
  }

  late final _CBB_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_CBB_cleanup>>('CBB_cleanup');
  late final _dart_CBB_cleanup _CBB_cleanup =
      _CBB_cleanup_ptr.asFunction<_dart_CBB_cleanup>();

  /// CBB_data returns a pointer to the bytes written to |cbb|. It does not flush
  /// |cbb|. The pointer is valid until the next operation to |cbb|.
  ///
  /// To avoid unfinalized length prefixes, it is a fatal error to call this on a
  /// CBB with any active children.
  ffi.Pointer<ffi.Uint8> CBB_data(
    ffi.Pointer<CBB> cbb,
  ) {
    return _CBB_data(
      cbb,
    );
  }

  late final _CBB_data_ptr =
      _lookup<ffi.NativeFunction<_c_CBB_data>>('CBB_data');
  late final _dart_CBB_data _CBB_data =
      _CBB_data_ptr.asFunction<_dart_CBB_data>();

  /// CBB_flush causes any pending length prefixes to be written out and any child
  /// |CBB| objects of |cbb| to be invalidated. This allows |cbb| to continue to be
  /// used after the children go out of scope, e.g. when local |CBB| objects are
  /// added as children to a |CBB| that persists after a function returns. This
  /// function returns one on success or zero on error.
  int CBB_flush(
    ffi.Pointer<CBB> cbb,
  ) {
    return _CBB_flush(
      cbb,
    );
  }

  late final _CBB_flush_ptr =
      _lookup<ffi.NativeFunction<_c_CBB_flush>>('CBB_flush');
  late final _dart_CBB_flush _CBB_flush =
      _CBB_flush_ptr.asFunction<_dart_CBB_flush>();

  /// CBB_init initialises |cbb| with |initial_capacity|. Since a |CBB| grows as
  /// needed, the |initial_capacity| is just a hint. It returns one on success or
  /// zero on allocation failure.
  int CBB_init(
    ffi.Pointer<CBB> cbb,
    int initial_capacity,
  ) {
    return _CBB_init(
      cbb,
      initial_capacity,
    );
  }

  late final _CBB_init_ptr =
      _lookup<ffi.NativeFunction<_c_CBB_init>>('CBB_init');
  late final _dart_CBB_init _CBB_init =
      _CBB_init_ptr.asFunction<_dart_CBB_init>();

  /// CBB_len returns the number of bytes written to |cbb|. It does not flush
  /// |cbb|.
  ///
  /// To avoid unfinalized length prefixes, it is a fatal error to call this on a
  /// CBB with any active children.
  int CBB_len(
    ffi.Pointer<CBB> cbb,
  ) {
    return _CBB_len(
      cbb,
    );
  }

  late final _CBB_len_ptr = _lookup<ffi.NativeFunction<_c_CBB_len>>('CBB_len');
  late final _dart_CBB_len _CBB_len = _CBB_len_ptr.asFunction<_dart_CBB_len>();

  /// CBB_zero sets an uninitialised |cbb| to the zero state. It must be
  /// initialised with |CBB_init| or |CBB_init_fixed| before use, but it is safe to
  /// call |CBB_cleanup| without a successful |CBB_init|. This may be used for more
  /// uniform cleanup of a |CBB|.
  void CBB_zero(
    ffi.Pointer<CBB> cbb,
  ) {
    return _CBB_zero(
      cbb,
    );
  }

  late final _CBB_zero_ptr =
      _lookup<ffi.NativeFunction<_c_CBB_zero>>('CBB_zero');
  late final _dart_CBB_zero _CBB_zero =
      _CBB_zero_ptr.asFunction<_dart_CBB_zero>();

  /// CBS_init sets |cbs| to point to |data|. It does not take ownership of
  /// |data|.
  void CBS_init(
    ffi.Pointer<CBS> cbs,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _CBS_init(
      cbs,
      data,
      len,
    );
  }

  late final _CBS_init_ptr =
      _lookup<ffi.NativeFunction<_c_CBS_init>>('CBS_init');
  late final _dart_CBS_init _CBS_init =
      _CBS_init_ptr.asFunction<_dart_CBS_init>();

  late final ffi.Pointer<ASN1_ITEM_st> _CERTIFICATEPOLICIES_it =
      _lookup<ASN1_ITEM_st>('CERTIFICATEPOLICIES_it');

  ffi.Pointer<ASN1_ITEM_st> get CERTIFICATEPOLICIES_it =>
      _CERTIFICATEPOLICIES_it;

  late final ffi.Pointer<ASN1_ITEM_st> _CRL_DIST_POINTS_it =
      _lookup<ASN1_ITEM_st>('CRL_DIST_POINTS_it');

  ffi.Pointer<ASN1_ITEM_st> get CRL_DIST_POINTS_it => _CRL_DIST_POINTS_it;

  /// CRYPTO_memcmp returns zero iff the |len| bytes at |a| and |b| are equal. It
  /// takes an amount of time dependent on |len|, but independent of the contents
  /// of |a| and |b|. Unlike memcmp, it cannot be used to put elements into a
  /// defined order as the return value when a != b is undefined, other than to be
  /// non-zero.
  int CRYPTO_memcmp(
    ffi.Pointer<ffi.Void> a,
    ffi.Pointer<ffi.Void> b,
    int len,
  ) {
    return _CRYPTO_memcmp(
      a,
      b,
      len,
    );
  }

  late final _CRYPTO_memcmp_ptr =
      _lookup<ffi.NativeFunction<_c_CRYPTO_memcmp>>('CRYPTO_memcmp');
  late final _dart_CRYPTO_memcmp _CRYPTO_memcmp =
      _CRYPTO_memcmp_ptr.asFunction<_dart_CRYPTO_memcmp>();

  late final ffi.Pointer<ASN1_ITEM_st> _DIRECTORYSTRING_it =
      _lookup<ASN1_ITEM_st>('DIRECTORYSTRING_it');

  ffi.Pointer<ASN1_ITEM_st> get DIRECTORYSTRING_it => _DIRECTORYSTRING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _DISPLAYTEXT_it =
      _lookup<ASN1_ITEM_st>('DISPLAYTEXT_it');

  ffi.Pointer<ASN1_ITEM_st> get DISPLAYTEXT_it => _DISPLAYTEXT_it;

  late final ffi.Pointer<ASN1_ITEM_st> _DIST_POINT_NAME_it =
      _lookup<ASN1_ITEM_st>('DIST_POINT_NAME_it');

  ffi.Pointer<ASN1_ITEM_st> get DIST_POINT_NAME_it => _DIST_POINT_NAME_it;

  late final ffi.Pointer<ASN1_ITEM_st> _DIST_POINT_it =
      _lookup<ASN1_ITEM_st>('DIST_POINT_it');

  ffi.Pointer<ASN1_ITEM_st> get DIST_POINT_it => _DIST_POINT_it;

  /// ECDH_compute_key calculates the shared key between |pub_key| and |priv_key|.
  /// If |kdf| is not NULL, then it is called with the bytes of the shared key and
  /// the parameter |out|. When |kdf| returns, the value of |*outlen| becomes the
  /// return value. Otherwise, as many bytes of the shared key as will fit are
  /// copied directly to, at most, |outlen| bytes at |out|. It returns the number
  /// of bytes written to |out|, or -1 on error.
  int ECDH_compute_key(
    ffi.Pointer<ffi.Void> out,
    int outlen,
    ffi.Pointer<EC_POINT> pub_key,
    ffi.Pointer<EC_KEY> priv_key,
    ffi.Pointer<ffi.NativeFunction<_typedefC_5>> kdf,
  ) {
    return _ECDH_compute_key(
      out,
      outlen,
      pub_key,
      priv_key,
      kdf,
    );
  }

  late final _ECDH_compute_key_ptr =
      _lookup<ffi.NativeFunction<_c_ECDH_compute_key>>('ECDH_compute_key');
  late final _dart_ECDH_compute_key _ECDH_compute_key =
      _ECDH_compute_key_ptr.asFunction<_dart_ECDH_compute_key>();

  /// ECDSA_SIG_free frees |sig| its member |BIGNUM|s.
  void ECDSA_SIG_free(
    ffi.Pointer<ECDSA_SIG> sig,
  ) {
    return _ECDSA_SIG_free(
      sig,
    );
  }

  late final _ECDSA_SIG_free_ptr =
      _lookup<ffi.NativeFunction<_c_ECDSA_SIG_free>>('ECDSA_SIG_free');
  late final _dart_ECDSA_SIG_free _ECDSA_SIG_free =
      _ECDSA_SIG_free_ptr.asFunction<_dart_ECDSA_SIG_free>();

  /// ECDSA_SIG_get0 sets |*out_r| and |*out_s|, if non-NULL, to the two
  /// components of |sig|.
  void ECDSA_SIG_get0(
    ffi.Pointer<ECDSA_SIG> sig,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_r,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_s,
  ) {
    return _ECDSA_SIG_get0(
      sig,
      out_r,
      out_s,
    );
  }

  late final _ECDSA_SIG_get0_ptr =
      _lookup<ffi.NativeFunction<_c_ECDSA_SIG_get0>>('ECDSA_SIG_get0');
  late final _dart_ECDSA_SIG_get0 _ECDSA_SIG_get0 =
      _ECDSA_SIG_get0_ptr.asFunction<_dart_ECDSA_SIG_get0>();

  /// ECDSA_SIG_marshal marshals |sig| as a DER-encoded ECDSA-Sig-Value and appends
  /// the result to |cbb|. It returns one on success and zero on error.
  int ECDSA_SIG_marshal(
    ffi.Pointer<CBB> cbb,
    ffi.Pointer<ECDSA_SIG> sig,
  ) {
    return _ECDSA_SIG_marshal(
      cbb,
      sig,
    );
  }

  late final _ECDSA_SIG_marshal_ptr =
      _lookup<ffi.NativeFunction<_c_ECDSA_SIG_marshal>>('ECDSA_SIG_marshal');
  late final _dart_ECDSA_SIG_marshal _ECDSA_SIG_marshal =
      _ECDSA_SIG_marshal_ptr.asFunction<_dart_ECDSA_SIG_marshal>();

  /// ECDSA_SIG_new returns a fresh |ECDSA_SIG| structure or NULL on error.
  ffi.Pointer<ECDSA_SIG> ECDSA_SIG_new() {
    return _ECDSA_SIG_new();
  }

  late final _ECDSA_SIG_new_ptr =
      _lookup<ffi.NativeFunction<_c_ECDSA_SIG_new>>('ECDSA_SIG_new');
  late final _dart_ECDSA_SIG_new _ECDSA_SIG_new =
      _ECDSA_SIG_new_ptr.asFunction<_dart_ECDSA_SIG_new>();

  /// ECDSA_SIG_parse parses a DER-encoded ECDSA-Sig-Value structure from |cbs| and
  /// advances |cbs|. It returns a newly-allocated |ECDSA_SIG| or NULL on error.
  ffi.Pointer<ECDSA_SIG> ECDSA_SIG_parse(
    ffi.Pointer<CBS> cbs,
  ) {
    return _ECDSA_SIG_parse(
      cbs,
    );
  }

  late final _ECDSA_SIG_parse_ptr =
      _lookup<ffi.NativeFunction<_c_ECDSA_SIG_parse>>('ECDSA_SIG_parse');
  late final _dart_ECDSA_SIG_parse _ECDSA_SIG_parse =
      _ECDSA_SIG_parse_ptr.asFunction<_dart_ECDSA_SIG_parse>();

  /// EC_GROUP_free releases a reference to |group|.
  void EC_GROUP_free(
    ffi.Pointer<EC_GROUP> group,
  ) {
    return _EC_GROUP_free(
      group,
    );
  }

  late final _EC_GROUP_free_ptr =
      _lookup<ffi.NativeFunction<_c_EC_GROUP_free>>('EC_GROUP_free');
  late final _dart_EC_GROUP_free _EC_GROUP_free =
      _EC_GROUP_free_ptr.asFunction<_dart_EC_GROUP_free>();

  /// EC_GROUP_get0_order returns a pointer to the internal |BIGNUM| object in
  /// |group| that specifies the order of the group.
  ffi.Pointer<BIGNUM> EC_GROUP_get0_order(
    ffi.Pointer<EC_GROUP> group,
  ) {
    return _EC_GROUP_get0_order(
      group,
    );
  }

  late final _EC_GROUP_get0_order_ptr =
      _lookup<ffi.NativeFunction<_c_EC_GROUP_get0_order>>(
          'EC_GROUP_get0_order');
  late final _dart_EC_GROUP_get0_order _EC_GROUP_get0_order =
      _EC_GROUP_get0_order_ptr.asFunction<_dart_EC_GROUP_get0_order>();

  /// EC_GROUP_get_curve_name returns a NID that identifies |group|.
  int EC_GROUP_get_curve_name(
    ffi.Pointer<EC_GROUP> group,
  ) {
    return _EC_GROUP_get_curve_name(
      group,
    );
  }

  late final _EC_GROUP_get_curve_name_ptr =
      _lookup<ffi.NativeFunction<_c_EC_GROUP_get_curve_name>>(
          'EC_GROUP_get_curve_name');
  late final _dart_EC_GROUP_get_curve_name _EC_GROUP_get_curve_name =
      _EC_GROUP_get_curve_name_ptr.asFunction<_dart_EC_GROUP_get_curve_name>();

  /// EC_GROUP_get_degree returns the number of bits needed to represent an
  /// element of the field underlying |group|.
  int EC_GROUP_get_degree(
    ffi.Pointer<EC_GROUP> group,
  ) {
    return _EC_GROUP_get_degree(
      group,
    );
  }

  late final _EC_GROUP_get_degree_ptr =
      _lookup<ffi.NativeFunction<_c_EC_GROUP_get_degree>>(
          'EC_GROUP_get_degree');
  late final _dart_EC_GROUP_get_degree _EC_GROUP_get_degree =
      _EC_GROUP_get_degree_ptr.asFunction<_dart_EC_GROUP_get_degree>();

  /// EC_GROUP_new_by_curve_name returns a fresh EC_GROUP object for the elliptic
  /// curve specified by |nid|, or NULL on unsupported NID or allocation failure.
  ///
  /// The supported NIDs are:
  /// NID_secp224r1 (P-224),
  /// NID_X9_62_prime256v1 (P-256),
  /// NID_secp384r1 (P-384),
  /// NID_secp521r1 (P-521)
  ///
  /// If in doubt, use |NID_X9_62_prime256v1|, or see the curve25519.h header for
  /// more modern primitives.
  ffi.Pointer<EC_GROUP> EC_GROUP_new_by_curve_name(
    int nid,
  ) {
    return _EC_GROUP_new_by_curve_name(
      nid,
    );
  }

  late final _EC_GROUP_new_by_curve_name_ptr =
      _lookup<ffi.NativeFunction<_c_EC_GROUP_new_by_curve_name>>(
          'EC_GROUP_new_by_curve_name');
  late final _dart_EC_GROUP_new_by_curve_name _EC_GROUP_new_by_curve_name =
      _EC_GROUP_new_by_curve_name_ptr.asFunction<
          _dart_EC_GROUP_new_by_curve_name>();

  /// EC_KEY_check_key performs several checks on |key| (possibly including an
  /// expensive check that the public key is in the primary subgroup). It returns
  /// one if all checks pass and zero otherwise. If it returns zero then detail
  /// about the problem can be found on the error stack.
  int EC_KEY_check_key(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_check_key(
      key,
    );
  }

  late final _EC_KEY_check_key_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_check_key>>('EC_KEY_check_key');
  late final _dart_EC_KEY_check_key _EC_KEY_check_key =
      _EC_KEY_check_key_ptr.asFunction<_dart_EC_KEY_check_key>();

  /// EC_KEY_free frees all the data owned by |key| and |key| itself.
  void EC_KEY_free(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_free(
      key,
    );
  }

  late final _EC_KEY_free_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_free>>('EC_KEY_free');
  late final _dart_EC_KEY_free _EC_KEY_free =
      _EC_KEY_free_ptr.asFunction<_dart_EC_KEY_free>();

  /// EC_KEY_generate_key generates a random, private key, calculates the
  /// corresponding public key and stores both in |key|. It returns one on success
  /// or zero otherwise.
  int EC_KEY_generate_key(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_generate_key(
      key,
    );
  }

  late final _EC_KEY_generate_key_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_generate_key>>(
          'EC_KEY_generate_key');
  late final _dart_EC_KEY_generate_key _EC_KEY_generate_key =
      _EC_KEY_generate_key_ptr.asFunction<_dart_EC_KEY_generate_key>();

  /// EC_KEY_get0_group returns a pointer to the |EC_GROUP| object inside |key|.
  ffi.Pointer<EC_GROUP> EC_KEY_get0_group(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_get0_group(
      key,
    );
  }

  late final _EC_KEY_get0_group_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_get0_group>>('EC_KEY_get0_group');
  late final _dart_EC_KEY_get0_group _EC_KEY_get0_group =
      _EC_KEY_get0_group_ptr.asFunction<_dart_EC_KEY_get0_group>();

  /// EC_KEY_get0_private_key returns a pointer to the private key inside |key|.
  ffi.Pointer<BIGNUM> EC_KEY_get0_private_key(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_get0_private_key(
      key,
    );
  }

  late final _EC_KEY_get0_private_key_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_get0_private_key>>(
          'EC_KEY_get0_private_key');
  late final _dart_EC_KEY_get0_private_key _EC_KEY_get0_private_key =
      _EC_KEY_get0_private_key_ptr.asFunction<_dart_EC_KEY_get0_private_key>();

  /// EC_KEY_get0_public_key returns a pointer to the public key point inside
  /// |key|.
  ffi.Pointer<EC_POINT> EC_KEY_get0_public_key(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_get0_public_key(
      key,
    );
  }

  late final _EC_KEY_get0_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_get0_public_key>>(
          'EC_KEY_get0_public_key');
  late final _dart_EC_KEY_get0_public_key _EC_KEY_get0_public_key =
      _EC_KEY_get0_public_key_ptr.asFunction<_dart_EC_KEY_get0_public_key>();

  /// EC_KEY_get_enc_flags returns the encoding flags for |key|, which is a
  /// bitwise-OR of |EC_PKEY_*| values.
  int EC_KEY_get_enc_flags(
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EC_KEY_get_enc_flags(
      key,
    );
  }

  late final _EC_KEY_get_enc_flags_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_get_enc_flags>>(
          'EC_KEY_get_enc_flags');
  late final _dart_EC_KEY_get_enc_flags _EC_KEY_get_enc_flags =
      _EC_KEY_get_enc_flags_ptr.asFunction<_dart_EC_KEY_get_enc_flags>();

  /// EC_KEY_new_by_curve_name returns a fresh EC_KEY for group specified by |nid|
  /// or NULL on error.
  ffi.Pointer<EC_KEY> EC_KEY_new_by_curve_name(
    int nid,
  ) {
    return _EC_KEY_new_by_curve_name(
      nid,
    );
  }

  late final _EC_KEY_new_by_curve_name_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_new_by_curve_name>>(
          'EC_KEY_new_by_curve_name');
  late final _dart_EC_KEY_new_by_curve_name _EC_KEY_new_by_curve_name =
      _EC_KEY_new_by_curve_name_ptr.asFunction<
          _dart_EC_KEY_new_by_curve_name>();

  /// EC_KEY_set_enc_flags sets the encoding flags for |key|, which is a
  /// bitwise-OR of |EC_PKEY_*| values.
  void EC_KEY_set_enc_flags(
    ffi.Pointer<EC_KEY> key,
    int flags,
  ) {
    return _EC_KEY_set_enc_flags(
      key,
      flags,
    );
  }

  late final _EC_KEY_set_enc_flags_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_set_enc_flags>>(
          'EC_KEY_set_enc_flags');
  late final _dart_EC_KEY_set_enc_flags _EC_KEY_set_enc_flags =
      _EC_KEY_set_enc_flags_ptr.asFunction<_dart_EC_KEY_set_enc_flags>();

  /// EC_KEY_set_private_key sets the private key of |key| to |priv|. It returns
  /// one on success and zero otherwise. |key| must already have had a group
  /// configured (see |EC_KEY_set_group| and |EC_KEY_new_by_curve_name|).
  int EC_KEY_set_private_key(
    ffi.Pointer<EC_KEY> key,
    ffi.Pointer<BIGNUM> priv,
  ) {
    return _EC_KEY_set_private_key(
      key,
      priv,
    );
  }

  late final _EC_KEY_set_private_key_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_set_private_key>>(
          'EC_KEY_set_private_key');
  late final _dart_EC_KEY_set_private_key _EC_KEY_set_private_key =
      _EC_KEY_set_private_key_ptr.asFunction<_dart_EC_KEY_set_private_key>();

  /// EC_KEY_set_public_key sets the public key of |key| to |pub|, by copying it.
  /// It returns one on success and zero otherwise. |key| must already have had a
  /// group configured (see |EC_KEY_set_group| and |EC_KEY_new_by_curve_name|), and
  /// |pub| must also belong to that group.
  int EC_KEY_set_public_key(
    ffi.Pointer<EC_KEY> key,
    ffi.Pointer<EC_POINT> pub,
  ) {
    return _EC_KEY_set_public_key(
      key,
      pub,
    );
  }

  late final _EC_KEY_set_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_set_public_key>>(
          'EC_KEY_set_public_key');
  late final _dart_EC_KEY_set_public_key _EC_KEY_set_public_key =
      _EC_KEY_set_public_key_ptr.asFunction<_dart_EC_KEY_set_public_key>();

  /// EC_KEY_set_public_key_affine_coordinates sets the public key in |key| to
  /// (|x|, |y|). It returns one on success and zero on error. It's considered an
  /// error if |x| and |y| do not represent a point on |key|'s curve.
  int EC_KEY_set_public_key_affine_coordinates(
    ffi.Pointer<EC_KEY> key,
    ffi.Pointer<BIGNUM> x,
    ffi.Pointer<BIGNUM> y,
  ) {
    return _EC_KEY_set_public_key_affine_coordinates(
      key,
      x,
      y,
    );
  }

  late final _EC_KEY_set_public_key_affine_coordinates_ptr =
      _lookup<ffi.NativeFunction<_c_EC_KEY_set_public_key_affine_coordinates>>(
          'EC_KEY_set_public_key_affine_coordinates');
  late final _dart_EC_KEY_set_public_key_affine_coordinates
      _EC_KEY_set_public_key_affine_coordinates =
      _EC_KEY_set_public_key_affine_coordinates_ptr.asFunction<
          _dart_EC_KEY_set_public_key_affine_coordinates>();

  /// EC_POINT_free frees |point| and the data that it points to.
  void EC_POINT_free(
    ffi.Pointer<EC_POINT> point,
  ) {
    return _EC_POINT_free(
      point,
    );
  }

  late final _EC_POINT_free_ptr =
      _lookup<ffi.NativeFunction<_c_EC_POINT_free>>('EC_POINT_free');
  late final _dart_EC_POINT_free _EC_POINT_free =
      _EC_POINT_free_ptr.asFunction<_dart_EC_POINT_free>();

  /// EC_POINT_get_affine_coordinates_GFp sets |x| and |y| to the affine value of
  /// |point| using |ctx|, if it's not NULL. It returns one on success and zero
  /// otherwise.
  ///
  /// Either |x| or |y| may be NULL to skip computing that coordinate. This is
  /// slightly faster in the common case where only the x-coordinate is needed.
  int EC_POINT_get_affine_coordinates_GFp(
    ffi.Pointer<EC_GROUP> group,
    ffi.Pointer<EC_POINT> point,
    ffi.Pointer<BIGNUM> x,
    ffi.Pointer<BIGNUM> y,
    ffi.Pointer<BN_CTX> ctx,
  ) {
    return _EC_POINT_get_affine_coordinates_GFp(
      group,
      point,
      x,
      y,
      ctx,
    );
  }

  late final _EC_POINT_get_affine_coordinates_GFp_ptr =
      _lookup<ffi.NativeFunction<_c_EC_POINT_get_affine_coordinates_GFp>>(
          'EC_POINT_get_affine_coordinates_GFp');
  late final _dart_EC_POINT_get_affine_coordinates_GFp
      _EC_POINT_get_affine_coordinates_GFp =
      _EC_POINT_get_affine_coordinates_GFp_ptr.asFunction<
          _dart_EC_POINT_get_affine_coordinates_GFp>();

  /// EC_POINT_new returns a fresh |EC_POINT| object in the given group, or NULL
  /// on error.
  ffi.Pointer<EC_POINT> EC_POINT_new(
    ffi.Pointer<EC_GROUP> group,
  ) {
    return _EC_POINT_new(
      group,
    );
  }

  late final _EC_POINT_new_ptr =
      _lookup<ffi.NativeFunction<_c_EC_POINT_new>>('EC_POINT_new');
  late final _dart_EC_POINT_new _EC_POINT_new =
      _EC_POINT_new_ptr.asFunction<_dart_EC_POINT_new>();

  /// EC_POINT_oct2point sets |point| from |len| bytes of X9.62 format
  /// serialisation in |buf|. It returns one on success and zero on error. The
  /// |ctx| argument may be used if not NULL. It's considered an error if |buf|
  /// does not represent a point on the curve.
  int EC_POINT_oct2point(
    ffi.Pointer<EC_GROUP> group,
    ffi.Pointer<EC_POINT> point,
    ffi.Pointer<ffi.Uint8> buf,
    int len,
    ffi.Pointer<BN_CTX> ctx,
  ) {
    return _EC_POINT_oct2point(
      group,
      point,
      buf,
      len,
      ctx,
    );
  }

  late final _EC_POINT_oct2point_ptr =
      _lookup<ffi.NativeFunction<_c_EC_POINT_oct2point>>('EC_POINT_oct2point');
  late final _dart_EC_POINT_oct2point _EC_POINT_oct2point =
      _EC_POINT_oct2point_ptr.asFunction<_dart_EC_POINT_oct2point>();

  /// EC_POINT_point2cbb behaves like |EC_POINT_point2oct| but appends the
  /// serialised point to |cbb|. It returns one on success and zero on error.
  int EC_POINT_point2cbb(
    ffi.Pointer<CBB> out,
    ffi.Pointer<EC_GROUP> group,
    ffi.Pointer<EC_POINT> point,
    int form,
    ffi.Pointer<BN_CTX> ctx,
  ) {
    return _EC_POINT_point2cbb(
      out,
      group,
      point,
      form,
      ctx,
    );
  }

  late final _EC_POINT_point2cbb_ptr =
      _lookup<ffi.NativeFunction<_c_EC_POINT_point2cbb>>('EC_POINT_point2cbb');
  late final _dart_EC_POINT_point2cbb _EC_POINT_point2cbb =
      _EC_POINT_point2cbb_ptr.asFunction<_dart_EC_POINT_point2cbb>();

  late final ffi.Pointer<ASN1_ITEM_st> _EDIPARTYNAME_it =
      _lookup<ASN1_ITEM_st>('EDIPARTYNAME_it');

  ffi.Pointer<ASN1_ITEM_st> get EDIPARTYNAME_it => _EDIPARTYNAME_it;

  /// ERR_clear_error clears the error queue for the current thread.
  void ERR_clear_error() {
    return _ERR_clear_error();
  }

  late final _ERR_clear_error_ptr =
      _lookup<ffi.NativeFunction<_c_ERR_clear_error>>('ERR_clear_error');
  late final _dart_ERR_clear_error _ERR_clear_error =
      _ERR_clear_error_ptr.asFunction<_dart_ERR_clear_error>();

  /// ERR_error_string_n generates a human-readable string representing
  /// |packed_error|, places it at |buf|, and returns |buf|. It writes at most
  /// |len| bytes (including the terminating NUL) and truncates the string if
  /// necessary. If |len| is greater than zero then |buf| is always NUL terminated.
  ///
  /// The string will have the following format:
  ///
  /// error:[error code]:[library name]:OPENSSL_internal:[reason string]
  ///
  /// error code is an 8 digit hexadecimal number; library name and reason string
  /// are ASCII text.
  ffi.Pointer<ffi.Int8> ERR_error_string_n(
    int packed_error,
    ffi.Pointer<ffi.Int8> buf,
    int len,
  ) {
    return _ERR_error_string_n(
      packed_error,
      buf,
      len,
    );
  }

  late final _ERR_error_string_n_ptr =
      _lookup<ffi.NativeFunction<_c_ERR_error_string_n>>('ERR_error_string_n');
  late final _dart_ERR_error_string_n _ERR_error_string_n =
      _ERR_error_string_n_ptr.asFunction<_dart_ERR_error_string_n>();

  /// ERR_get_error gets the packed error code for the least recent error and
  /// removes that error from the queue. If there are no errors in the queue then
  /// it returns zero.
  int ERR_get_error() {
    return _ERR_get_error();
  }

  late final _ERR_get_error_ptr =
      _lookup<ffi.NativeFunction<_c_ERR_get_error>>('ERR_get_error');
  late final _dart_ERR_get_error _ERR_get_error =
      _ERR_get_error_ptr.asFunction<_dart_ERR_get_error>();

  /// The "peek" functions act like the |ERR_get_error| functions, above, but they
  /// do not remove the error from the queue.
  int ERR_peek_error() {
    return _ERR_peek_error();
  }

  late final _ERR_peek_error_ptr =
      _lookup<ffi.NativeFunction<_c_ERR_peek_error>>('ERR_peek_error');
  late final _dart_ERR_peek_error _ERR_peek_error =
      _ERR_peek_error_ptr.asFunction<_dart_ERR_peek_error>();

  /// EVP_AEAD_CTX_free calls |EVP_AEAD_CTX_cleanup| and |OPENSSL_free| on
  /// |ctx|.
  void EVP_AEAD_CTX_free(
    ffi.Pointer<EVP_AEAD_CTX> ctx,
  ) {
    return _EVP_AEAD_CTX_free(
      ctx,
    );
  }

  late final _EVP_AEAD_CTX_free_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_CTX_free>>('EVP_AEAD_CTX_free');
  late final _dart_EVP_AEAD_CTX_free _EVP_AEAD_CTX_free =
      _EVP_AEAD_CTX_free_ptr.asFunction<_dart_EVP_AEAD_CTX_free>();

  /// EVP_AEAD_CTX_new allocates an |EVP_AEAD_CTX|, calls |EVP_AEAD_CTX_init| and
  /// returns the |EVP_AEAD_CTX|, or NULL on error.
  ffi.Pointer<EVP_AEAD_CTX> EVP_AEAD_CTX_new(
    ffi.Pointer<EVP_AEAD> aead,
    ffi.Pointer<ffi.Uint8> key,
    int key_len,
    int tag_len,
  ) {
    return _EVP_AEAD_CTX_new(
      aead,
      key,
      key_len,
      tag_len,
    );
  }

  late final _EVP_AEAD_CTX_new_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_CTX_new>>('EVP_AEAD_CTX_new');
  late final _dart_EVP_AEAD_CTX_new _EVP_AEAD_CTX_new =
      _EVP_AEAD_CTX_new_ptr.asFunction<_dart_EVP_AEAD_CTX_new>();

  /// EVP_AEAD_CTX_open authenticates |in_len| bytes from |in| and |ad_len| bytes
  /// from |ad| and decrypts at most |in_len| bytes into |out|. It returns one on
  /// success and zero otherwise.
  ///
  /// This function may be called concurrently with itself or any other seal/open
  /// function on the same |EVP_AEAD_CTX|.
  ///
  /// At most |in_len| bytes are written to |out|. In order to ensure success,
  /// |max_out_len| should be at least |in_len|. On successful return, |*out_len|
  /// is set to the the actual number of bytes written.
  ///
  /// The length of |nonce|, |nonce_len|, must be equal to the result of
  /// |EVP_AEAD_nonce_length| for this AEAD.
  ///
  /// |EVP_AEAD_CTX_open| never results in a partial output. If |max_out_len| is
  /// insufficient, zero will be returned. If any error occurs, |out| will be
  /// filled with zero bytes and |*out_len| set to zero.
  ///
  /// If |in| and |out| alias then |out| must be == |in|.
  int EVP_AEAD_CTX_open(
    ffi.Pointer<EVP_AEAD_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.IntPtr> out_len,
    int max_out_len,
    ffi.Pointer<ffi.Uint8> nonce,
    int nonce_len,
    ffi.Pointer<ffi.Uint8> in_1,
    int in_len,
    ffi.Pointer<ffi.Uint8> ad,
    int ad_len,
  ) {
    return _EVP_AEAD_CTX_open(
      ctx,
      out,
      out_len,
      max_out_len,
      nonce,
      nonce_len,
      in_1,
      in_len,
      ad,
      ad_len,
    );
  }

  late final _EVP_AEAD_CTX_open_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_CTX_open>>('EVP_AEAD_CTX_open');
  late final _dart_EVP_AEAD_CTX_open _EVP_AEAD_CTX_open =
      _EVP_AEAD_CTX_open_ptr.asFunction<_dart_EVP_AEAD_CTX_open>();

  /// EVP_AEAD_CTX_seal encrypts and authenticates |in_len| bytes from |in| and
  /// authenticates |ad_len| bytes from |ad| and writes the result to |out|. It
  /// returns one on success and zero otherwise.
  ///
  /// This function may be called concurrently with itself or any other seal/open
  /// function on the same |EVP_AEAD_CTX|.
  ///
  /// At most |max_out_len| bytes are written to |out| and, in order to ensure
  /// success, |max_out_len| should be |in_len| plus the result of
  /// |EVP_AEAD_max_overhead|. On successful return, |*out_len| is set to the
  /// actual number of bytes written.
  ///
  /// The length of |nonce|, |nonce_len|, must be equal to the result of
  /// |EVP_AEAD_nonce_length| for this AEAD.
  ///
  /// |EVP_AEAD_CTX_seal| never results in a partial output. If |max_out_len| is
  /// insufficient, zero will be returned. If any error occurs, |out| will be
  /// filled with zero bytes and |*out_len| set to zero.
  ///
  /// If |in| and |out| alias then |out| must be == |in|.
  int EVP_AEAD_CTX_seal(
    ffi.Pointer<EVP_AEAD_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.IntPtr> out_len,
    int max_out_len,
    ffi.Pointer<ffi.Uint8> nonce,
    int nonce_len,
    ffi.Pointer<ffi.Uint8> in_1,
    int in_len,
    ffi.Pointer<ffi.Uint8> ad,
    int ad_len,
  ) {
    return _EVP_AEAD_CTX_seal(
      ctx,
      out,
      out_len,
      max_out_len,
      nonce,
      nonce_len,
      in_1,
      in_len,
      ad,
      ad_len,
    );
  }

  late final _EVP_AEAD_CTX_seal_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_CTX_seal>>('EVP_AEAD_CTX_seal');
  late final _dart_EVP_AEAD_CTX_seal _EVP_AEAD_CTX_seal =
      _EVP_AEAD_CTX_seal_ptr.asFunction<_dart_EVP_AEAD_CTX_seal>();

  /// EVP_AEAD_key_length returns the length, in bytes, of the keys used by
  /// |aead|.
  int EVP_AEAD_key_length(
    ffi.Pointer<EVP_AEAD> aead,
  ) {
    return _EVP_AEAD_key_length(
      aead,
    );
  }

  late final _EVP_AEAD_key_length_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_key_length>>(
          'EVP_AEAD_key_length');
  late final _dart_EVP_AEAD_key_length _EVP_AEAD_key_length =
      _EVP_AEAD_key_length_ptr.asFunction<_dart_EVP_AEAD_key_length>();

  /// EVP_AEAD_max_overhead returns the maximum number of additional bytes added
  /// by the act of sealing data with |aead|.
  int EVP_AEAD_max_overhead(
    ffi.Pointer<EVP_AEAD> aead,
  ) {
    return _EVP_AEAD_max_overhead(
      aead,
    );
  }

  late final _EVP_AEAD_max_overhead_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_max_overhead>>(
          'EVP_AEAD_max_overhead');
  late final _dart_EVP_AEAD_max_overhead _EVP_AEAD_max_overhead =
      _EVP_AEAD_max_overhead_ptr.asFunction<_dart_EVP_AEAD_max_overhead>();

  /// EVP_AEAD_max_tag_len returns the maximum tag length when using |aead|. This
  /// is the largest value that can be passed as |tag_len| to
  /// |EVP_AEAD_CTX_init|.
  int EVP_AEAD_max_tag_len(
    ffi.Pointer<EVP_AEAD> aead,
  ) {
    return _EVP_AEAD_max_tag_len(
      aead,
    );
  }

  late final _EVP_AEAD_max_tag_len_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_max_tag_len>>(
          'EVP_AEAD_max_tag_len');
  late final _dart_EVP_AEAD_max_tag_len _EVP_AEAD_max_tag_len =
      _EVP_AEAD_max_tag_len_ptr.asFunction<_dart_EVP_AEAD_max_tag_len>();

  /// EVP_AEAD_nonce_length returns the length, in bytes, of the per-message nonce
  /// for |aead|.
  int EVP_AEAD_nonce_length(
    ffi.Pointer<EVP_AEAD> aead,
  ) {
    return _EVP_AEAD_nonce_length(
      aead,
    );
  }

  late final _EVP_AEAD_nonce_length_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_AEAD_nonce_length>>(
          'EVP_AEAD_nonce_length');
  late final _dart_EVP_AEAD_nonce_length _EVP_AEAD_nonce_length =
      _EVP_AEAD_nonce_length_ptr.asFunction<_dart_EVP_AEAD_nonce_length>();

  /// EVP_CIPHER_CTX_free calls |EVP_CIPHER_CTX_cleanup| on |ctx| and then frees
  /// |ctx| itself.
  void EVP_CIPHER_CTX_free(
    ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ) {
    return _EVP_CIPHER_CTX_free(
      ctx,
    );
  }

  late final _EVP_CIPHER_CTX_free_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CIPHER_CTX_free>>(
          'EVP_CIPHER_CTX_free');
  late final _dart_EVP_CIPHER_CTX_free _EVP_CIPHER_CTX_free =
      _EVP_CIPHER_CTX_free_ptr.asFunction<_dart_EVP_CIPHER_CTX_free>();

  /// EVP_CIPHER_CTX_new allocates a fresh |EVP_CIPHER_CTX|, calls
  /// |EVP_CIPHER_CTX_init| and returns it, or NULL on allocation failure.
  ffi.Pointer<EVP_CIPHER_CTX> EVP_CIPHER_CTX_new() {
    return _EVP_CIPHER_CTX_new();
  }

  late final _EVP_CIPHER_CTX_new_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CIPHER_CTX_new>>('EVP_CIPHER_CTX_new');
  late final _dart_EVP_CIPHER_CTX_new _EVP_CIPHER_CTX_new =
      _EVP_CIPHER_CTX_new_ptr.asFunction<_dart_EVP_CIPHER_CTX_new>();

  /// EVP_CIPHER_block_size returns the block size, in bytes, for |cipher|, or one
  /// if |cipher| is a stream cipher.
  int EVP_CIPHER_block_size(
    ffi.Pointer<EVP_CIPHER> cipher,
  ) {
    return _EVP_CIPHER_block_size(
      cipher,
    );
  }

  late final _EVP_CIPHER_block_size_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CIPHER_block_size>>(
          'EVP_CIPHER_block_size');
  late final _dart_EVP_CIPHER_block_size _EVP_CIPHER_block_size =
      _EVP_CIPHER_block_size_ptr.asFunction<_dart_EVP_CIPHER_block_size>();

  /// EVP_CIPHER_iv_length returns the IV size, in bytes, of |cipher|, or zero if
  /// |cipher| doesn't take an IV.
  int EVP_CIPHER_iv_length(
    ffi.Pointer<EVP_CIPHER> cipher,
  ) {
    return _EVP_CIPHER_iv_length(
      cipher,
    );
  }

  late final _EVP_CIPHER_iv_length_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CIPHER_iv_length>>(
          'EVP_CIPHER_iv_length');
  late final _dart_EVP_CIPHER_iv_length _EVP_CIPHER_iv_length =
      _EVP_CIPHER_iv_length_ptr.asFunction<_dart_EVP_CIPHER_iv_length>();

  /// EVP_CipherFinal_ex calls either |EVP_EncryptFinal_ex| or
  /// |EVP_DecryptFinal_ex| depending on how |ctx| has been setup.
  int EVP_CipherFinal_ex(
    ffi.Pointer<EVP_CIPHER_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Int32> out_len,
  ) {
    return _EVP_CipherFinal_ex(
      ctx,
      out,
      out_len,
    );
  }

  late final _EVP_CipherFinal_ex_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CipherFinal_ex>>('EVP_CipherFinal_ex');
  late final _dart_EVP_CipherFinal_ex _EVP_CipherFinal_ex =
      _EVP_CipherFinal_ex_ptr.asFunction<_dart_EVP_CipherFinal_ex>();

  /// EVP_CipherInit_ex configures |ctx| for a fresh encryption (or decryption, if
  /// |enc| is zero) operation using |cipher|. If |ctx| has been previously
  /// configured with a cipher then |cipher|, |key| and |iv| may be |NULL| and
  /// |enc| may be -1 to reuse the previous values. The operation will use |key|
  /// as the key and |iv| as the IV (if any). These should have the correct
  /// lengths given by |EVP_CIPHER_key_length| and |EVP_CIPHER_iv_length|. It
  /// returns one on success and zero on error.
  int EVP_CipherInit_ex(
    ffi.Pointer<EVP_CIPHER_CTX> ctx,
    ffi.Pointer<EVP_CIPHER> cipher,
    ffi.Pointer<ENGINE> engine,
    ffi.Pointer<ffi.Uint8> key,
    ffi.Pointer<ffi.Uint8> iv,
    int enc,
  ) {
    return _EVP_CipherInit_ex(
      ctx,
      cipher,
      engine,
      key,
      iv,
      enc,
    );
  }

  late final _EVP_CipherInit_ex_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CipherInit_ex>>('EVP_CipherInit_ex');
  late final _dart_EVP_CipherInit_ex _EVP_CipherInit_ex =
      _EVP_CipherInit_ex_ptr.asFunction<_dart_EVP_CipherInit_ex>();

  /// EVP_CipherUpdate calls either |EVP_EncryptUpdate| or |EVP_DecryptUpdate|
  /// depending on how |ctx| has been setup.
  int EVP_CipherUpdate(
    ffi.Pointer<EVP_CIPHER_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Int32> out_len,
    ffi.Pointer<ffi.Uint8> in_1,
    int in_len,
  ) {
    return _EVP_CipherUpdate(
      ctx,
      out,
      out_len,
      in_1,
      in_len,
    );
  }

  late final _EVP_CipherUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_CipherUpdate>>('EVP_CipherUpdate');
  late final _dart_EVP_CipherUpdate _EVP_CipherUpdate =
      _EVP_CipherUpdate_ptr.asFunction<_dart_EVP_CipherUpdate>();

  /// EVP_DigestFinal acts like |EVP_DigestFinal_ex| except that
  /// |EVP_MD_CTX_cleanup| is called on |ctx| before returning.
  int EVP_DigestFinal(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Uint8> md_out,
    ffi.Pointer<ffi.Uint32> out_size,
  ) {
    return _EVP_DigestFinal(
      ctx,
      md_out,
      out_size,
    );
  }

  late final _EVP_DigestFinal_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestFinal>>('EVP_DigestFinal');
  late final _dart_EVP_DigestFinal _EVP_DigestFinal =
      _EVP_DigestFinal_ptr.asFunction<_dart_EVP_DigestFinal>();

  /// EVP_DigestInit acts like |EVP_DigestInit_ex| except that |ctx| is
  /// initialised before use.
  int EVP_DigestInit(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<EVP_MD> type,
  ) {
    return _EVP_DigestInit(
      ctx,
      type,
    );
  }

  late final _EVP_DigestInit_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestInit>>('EVP_DigestInit');
  late final _dart_EVP_DigestInit _EVP_DigestInit =
      _EVP_DigestInit_ptr.asFunction<_dart_EVP_DigestInit>();

  /// EVP_DigestSignFinal signs the data that has been included by one or more
  /// calls to |EVP_DigestSignUpdate|. If |out_sig| is NULL then |*out_sig_len| is
  /// set to the maximum number of output bytes. Otherwise, on entry,
  /// |*out_sig_len| must contain the length of the |out_sig| buffer. If the call
  /// is successful, the signature is written to |out_sig| and |*out_sig_len| is
  /// set to its length.
  ///
  /// This function performs a streaming signing operation and will fail for
  /// signature algorithms which do not support this. Use |EVP_DigestSign| for a
  /// single-shot operation.
  ///
  /// It returns one on success, or zero on error.
  int EVP_DigestSignFinal(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out_sig,
    ffi.Pointer<ffi.IntPtr> out_sig_len,
  ) {
    return _EVP_DigestSignFinal(
      ctx,
      out_sig,
      out_sig_len,
    );
  }

  late final _EVP_DigestSignFinal_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestSignFinal>>(
          'EVP_DigestSignFinal');
  late final _dart_EVP_DigestSignFinal _EVP_DigestSignFinal =
      _EVP_DigestSignFinal_ptr.asFunction<_dart_EVP_DigestSignFinal>();

  /// EVP_DigestSignInit sets up |ctx| for a signing operation with |type| and
  /// |pkey|. The |ctx| argument must have been initialised with
  /// |EVP_MD_CTX_init|. If |pctx| is not NULL, the |EVP_PKEY_CTX| of the signing
  /// operation will be written to |*pctx|; this can be used to set alternative
  /// signing options.
  ///
  /// For single-shot signing algorithms which do not use a pre-hash, such as
  /// Ed25519, |type| should be NULL. The |EVP_MD_CTX| itself is unused but is
  /// present so the API is uniform. See |EVP_DigestSign|.
  ///
  /// This function does not mutate |pkey| for thread-safety purposes and may be
  /// used concurrently with other non-mutating functions on |pkey|.
  ///
  /// It returns one on success, or zero on error.
  int EVP_DigestSignInit(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Pointer<EVP_PKEY_CTX>> pctx,
    ffi.Pointer<EVP_MD> type,
    ffi.Pointer<ENGINE> e,
    ffi.Pointer<EVP_PKEY> pkey,
  ) {
    return _EVP_DigestSignInit(
      ctx,
      pctx,
      type,
      e,
      pkey,
    );
  }

  late final _EVP_DigestSignInit_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestSignInit>>('EVP_DigestSignInit');
  late final _dart_EVP_DigestSignInit _EVP_DigestSignInit =
      _EVP_DigestSignInit_ptr.asFunction<_dart_EVP_DigestSignInit>();

  /// EVP_DigestSignUpdate appends |len| bytes from |data| to the data which will
  /// be signed in |EVP_DigestSignFinal|. It returns one.
  ///
  /// This function performs a streaming signing operation and will fail for
  /// signature algorithms which do not support this. Use |EVP_DigestSign| for a
  /// single-shot operation.
  int EVP_DigestSignUpdate(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _EVP_DigestSignUpdate(
      ctx,
      data,
      len,
    );
  }

  late final _EVP_DigestSignUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestSignUpdate>>(
          'EVP_DigestSignUpdate');
  late final _dart_EVP_DigestSignUpdate _EVP_DigestSignUpdate =
      _EVP_DigestSignUpdate_ptr.asFunction<_dart_EVP_DigestSignUpdate>();

  /// EVP_DigestUpdate hashes |len| bytes from |data| into the hashing operation
  /// in |ctx|. It returns one.
  int EVP_DigestUpdate(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _EVP_DigestUpdate(
      ctx,
      data,
      len,
    );
  }

  late final _EVP_DigestUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestUpdate>>('EVP_DigestUpdate');
  late final _dart_EVP_DigestUpdate _EVP_DigestUpdate =
      _EVP_DigestUpdate_ptr.asFunction<_dart_EVP_DigestUpdate>();

  /// EVP_DigestVerifyFinal verifies that |sig_len| bytes of |sig| are a valid
  /// signature for the data that has been included by one or more calls to
  /// |EVP_DigestVerifyUpdate|. It returns one on success and zero otherwise.
  ///
  /// This function performs streaming signature verification and will fail for
  /// signature algorithms which do not support this. Use |EVP_PKEY_verify_message|
  /// for a single-shot verification.
  int EVP_DigestVerifyFinal(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Uint8> sig,
    int sig_len,
  ) {
    return _EVP_DigestVerifyFinal(
      ctx,
      sig,
      sig_len,
    );
  }

  late final _EVP_DigestVerifyFinal_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestVerifyFinal>>(
          'EVP_DigestVerifyFinal');
  late final _dart_EVP_DigestVerifyFinal _EVP_DigestVerifyFinal =
      _EVP_DigestVerifyFinal_ptr.asFunction<_dart_EVP_DigestVerifyFinal>();

  /// EVP_DigestVerifyInit sets up |ctx| for a signature verification operation
  /// with |type| and |pkey|. The |ctx| argument must have been initialised with
  /// |EVP_MD_CTX_init|. If |pctx| is not NULL, the |EVP_PKEY_CTX| of the signing
  /// operation will be written to |*pctx|; this can be used to set alternative
  /// signing options.
  ///
  /// For single-shot signing algorithms which do not use a pre-hash, such as
  /// Ed25519, |type| should be NULL. The |EVP_MD_CTX| itself is unused but is
  /// present so the API is uniform. See |EVP_DigestVerify|.
  ///
  /// This function does not mutate |pkey| for thread-safety purposes and may be
  /// used concurrently with other non-mutating functions on |pkey|.
  ///
  /// It returns one on success, or zero on error.
  int EVP_DigestVerifyInit(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Pointer<EVP_PKEY_CTX>> pctx,
    ffi.Pointer<EVP_MD> type,
    ffi.Pointer<ENGINE> e,
    ffi.Pointer<EVP_PKEY> pkey,
  ) {
    return _EVP_DigestVerifyInit(
      ctx,
      pctx,
      type,
      e,
      pkey,
    );
  }

  late final _EVP_DigestVerifyInit_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestVerifyInit>>(
          'EVP_DigestVerifyInit');
  late final _dart_EVP_DigestVerifyInit _EVP_DigestVerifyInit =
      _EVP_DigestVerifyInit_ptr.asFunction<_dart_EVP_DigestVerifyInit>();

  /// EVP_DigestVerifyUpdate appends |len| bytes from |data| to the data which
  /// will be verified by |EVP_DigestVerifyFinal|. It returns one.
  ///
  /// This function performs streaming signature verification and will fail for
  /// signature algorithms which do not support this. Use |EVP_PKEY_verify_message|
  /// for a single-shot verification.
  int EVP_DigestVerifyUpdate(
    ffi.Pointer<EVP_MD_CTX> ctx,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _EVP_DigestVerifyUpdate(
      ctx,
      data,
      len,
    );
  }

  late final _EVP_DigestVerifyUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_DigestVerifyUpdate>>(
          'EVP_DigestVerifyUpdate');
  late final _dart_EVP_DigestVerifyUpdate _EVP_DigestVerifyUpdate =
      _EVP_DigestVerifyUpdate_ptr.asFunction<_dart_EVP_DigestVerifyUpdate>();

  /// EVP_MD_CTX_free calls |EVP_MD_CTX_cleanup| and then frees |ctx| itself.
  void EVP_MD_CTX_free(
    ffi.Pointer<EVP_MD_CTX> ctx,
  ) {
    return _EVP_MD_CTX_free(
      ctx,
    );
  }

  late final _EVP_MD_CTX_free_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_MD_CTX_free>>('EVP_MD_CTX_free');
  late final _dart_EVP_MD_CTX_free _EVP_MD_CTX_free =
      _EVP_MD_CTX_free_ptr.asFunction<_dart_EVP_MD_CTX_free>();

  /// EVP_MD_CTX_new allocates and initialises a fresh |EVP_MD_CTX| and returns
  /// it, or NULL on allocation failure. The caller must use |EVP_MD_CTX_free| to
  /// release the resulting object.
  ffi.Pointer<EVP_MD_CTX> EVP_MD_CTX_new() {
    return _EVP_MD_CTX_new();
  }

  late final _EVP_MD_CTX_new_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_MD_CTX_new>>('EVP_MD_CTX_new');
  late final _dart_EVP_MD_CTX_new _EVP_MD_CTX_new =
      _EVP_MD_CTX_new_ptr.asFunction<_dart_EVP_MD_CTX_new>();

  /// EVP_MD_CTX_size returns the digest size of |ctx|, in bytes. It
  /// will crash if a digest hasn't been set on |ctx|.
  int EVP_MD_CTX_size(
    ffi.Pointer<EVP_MD_CTX> ctx,
  ) {
    return _EVP_MD_CTX_size(
      ctx,
    );
  }

  late final _EVP_MD_CTX_size_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_MD_CTX_size>>('EVP_MD_CTX_size');
  late final _dart_EVP_MD_CTX_size _EVP_MD_CTX_size =
      _EVP_MD_CTX_size_ptr.asFunction<_dart_EVP_MD_CTX_size>();

  /// EVP_MD_size returns the digest size of |md|, in bytes.
  int EVP_MD_size(
    ffi.Pointer<EVP_MD> md,
  ) {
    return _EVP_MD_size(
      md,
    );
  }

  late final _EVP_MD_size_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_MD_size>>('EVP_MD_size');
  late final _dart_EVP_MD_size _EVP_MD_size =
      _EVP_MD_size_ptr.asFunction<_dart_EVP_MD_size>();

  /// EVP_PKEY_CTX_free frees |ctx| and the data it owns.
  void EVP_PKEY_CTX_free(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
  ) {
    return _EVP_PKEY_CTX_free(
      ctx,
    );
  }

  late final _EVP_PKEY_CTX_free_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_free>>('EVP_PKEY_CTX_free');
  late final _dart_EVP_PKEY_CTX_free _EVP_PKEY_CTX_free =
      _EVP_PKEY_CTX_free_ptr.asFunction<_dart_EVP_PKEY_CTX_free>();

  /// EVP_PKEY_CTX_new allocates a fresh |EVP_PKEY_CTX| for use with |pkey|. It
  /// returns the context or NULL on error.
  ffi.Pointer<EVP_PKEY_CTX> EVP_PKEY_CTX_new(
    ffi.Pointer<EVP_PKEY> pkey,
    ffi.Pointer<ENGINE> e,
  ) {
    return _EVP_PKEY_CTX_new(
      pkey,
      e,
    );
  }

  late final _EVP_PKEY_CTX_new_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_new>>('EVP_PKEY_CTX_new');
  late final _dart_EVP_PKEY_CTX_new _EVP_PKEY_CTX_new =
      _EVP_PKEY_CTX_new_ptr.asFunction<_dart_EVP_PKEY_CTX_new>();

  /// EVP_PKEY_CTX_set0_rsa_oaep_label sets |label_len| bytes from |label| as the
  /// label used in OAEP. DANGER: On success, this call takes ownership of |label|
  /// and will call |OPENSSL_free| on it when |ctx| is destroyed.
  ///
  /// Returns one on success or zero on error.
  int EVP_PKEY_CTX_set0_rsa_oaep_label(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    ffi.Pointer<ffi.Uint8> label,
    int label_len,
  ) {
    return _EVP_PKEY_CTX_set0_rsa_oaep_label(
      ctx,
      label,
      label_len,
    );
  }

  late final _EVP_PKEY_CTX_set0_rsa_oaep_label_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_set0_rsa_oaep_label>>(
          'EVP_PKEY_CTX_set0_rsa_oaep_label');
  late final _dart_EVP_PKEY_CTX_set0_rsa_oaep_label
      _EVP_PKEY_CTX_set0_rsa_oaep_label = _EVP_PKEY_CTX_set0_rsa_oaep_label_ptr
          .asFunction<_dart_EVP_PKEY_CTX_set0_rsa_oaep_label>();

  /// EVP_PKEY_CTX_set_rsa_mgf1_md sets |md| as the digest used in MGF1. Returns
  /// one on success or zero on error.
  int EVP_PKEY_CTX_set_rsa_mgf1_md(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    ffi.Pointer<EVP_MD> md,
  ) {
    return _EVP_PKEY_CTX_set_rsa_mgf1_md(
      ctx,
      md,
    );
  }

  late final _EVP_PKEY_CTX_set_rsa_mgf1_md_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_set_rsa_mgf1_md>>(
          'EVP_PKEY_CTX_set_rsa_mgf1_md');
  late final _dart_EVP_PKEY_CTX_set_rsa_mgf1_md _EVP_PKEY_CTX_set_rsa_mgf1_md =
      _EVP_PKEY_CTX_set_rsa_mgf1_md_ptr.asFunction<
          _dart_EVP_PKEY_CTX_set_rsa_mgf1_md>();

  /// EVP_PKEY_CTX_set_rsa_oaep_md sets |md| as the digest used in OAEP padding.
  /// Returns one on success or zero on error.
  int EVP_PKEY_CTX_set_rsa_oaep_md(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    ffi.Pointer<EVP_MD> md,
  ) {
    return _EVP_PKEY_CTX_set_rsa_oaep_md(
      ctx,
      md,
    );
  }

  late final _EVP_PKEY_CTX_set_rsa_oaep_md_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_set_rsa_oaep_md>>(
          'EVP_PKEY_CTX_set_rsa_oaep_md');
  late final _dart_EVP_PKEY_CTX_set_rsa_oaep_md _EVP_PKEY_CTX_set_rsa_oaep_md =
      _EVP_PKEY_CTX_set_rsa_oaep_md_ptr.asFunction<
          _dart_EVP_PKEY_CTX_set_rsa_oaep_md>();

  /// EVP_PKEY_CTX_set_rsa_padding sets the padding type to use. It should be one
  /// of the |RSA_*_PADDING| values. Returns one on success or zero on error.
  int EVP_PKEY_CTX_set_rsa_padding(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    int padding,
  ) {
    return _EVP_PKEY_CTX_set_rsa_padding(
      ctx,
      padding,
    );
  }

  late final _EVP_PKEY_CTX_set_rsa_padding_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_set_rsa_padding>>(
          'EVP_PKEY_CTX_set_rsa_padding');
  late final _dart_EVP_PKEY_CTX_set_rsa_padding _EVP_PKEY_CTX_set_rsa_padding =
      _EVP_PKEY_CTX_set_rsa_padding_ptr.asFunction<
          _dart_EVP_PKEY_CTX_set_rsa_padding>();

  /// EVP_PKEY_CTX_set_rsa_pss_saltlen sets the length of the salt in a PSS-padded
  /// signature. A value of -1 cause the salt to be the same length as the digest
  /// in the signature. A value of -2 causes the salt to be the maximum length
  /// that will fit when signing and recovered from the signature when verifying.
  /// Otherwise the value gives the size of the salt in bytes.
  ///
  /// If unsure, use -1.
  ///
  /// Returns one on success or zero on error.
  int EVP_PKEY_CTX_set_rsa_pss_saltlen(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    int salt_len,
  ) {
    return _EVP_PKEY_CTX_set_rsa_pss_saltlen(
      ctx,
      salt_len,
    );
  }

  late final _EVP_PKEY_CTX_set_rsa_pss_saltlen_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_CTX_set_rsa_pss_saltlen>>(
          'EVP_PKEY_CTX_set_rsa_pss_saltlen');
  late final _dart_EVP_PKEY_CTX_set_rsa_pss_saltlen
      _EVP_PKEY_CTX_set_rsa_pss_saltlen = _EVP_PKEY_CTX_set_rsa_pss_saltlen_ptr
          .asFunction<_dart_EVP_PKEY_CTX_set_rsa_pss_saltlen>();

  /// EVP_PKEY_decrypt decrypts |in_len| bytes from |in|. If |out| is NULL, the
  /// maximum size of the plaintext is written to |out_len|. Otherwise, |*out_len|
  /// must contain the number of bytes of space available at |out|. If sufficient,
  /// the ciphertext will be written to |out| and |*out_len| updated with the true
  /// length.
  ///
  /// WARNING: Setting |out| to NULL only gives the maximum size of the
  /// plaintext. The actual plaintext may be smaller.
  ///
  /// It returns one on success or zero on error.
  int EVP_PKEY_decrypt(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.IntPtr> out_len,
    ffi.Pointer<ffi.Uint8> in_1,
    int in_len,
  ) {
    return _EVP_PKEY_decrypt(
      ctx,
      out,
      out_len,
      in_1,
      in_len,
    );
  }

  late final _EVP_PKEY_decrypt_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_decrypt>>('EVP_PKEY_decrypt');
  late final _dart_EVP_PKEY_decrypt _EVP_PKEY_decrypt =
      _EVP_PKEY_decrypt_ptr.asFunction<_dart_EVP_PKEY_decrypt>();

  /// EVP_PKEY_decrypt_init initialises an |EVP_PKEY_CTX| for a decryption
  /// operation. It should be called before |EVP_PKEY_decrypt|.
  ///
  /// It returns one on success or zero on error.
  int EVP_PKEY_decrypt_init(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
  ) {
    return _EVP_PKEY_decrypt_init(
      ctx,
    );
  }

  late final _EVP_PKEY_decrypt_init_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_decrypt_init>>(
          'EVP_PKEY_decrypt_init');
  late final _dart_EVP_PKEY_decrypt_init _EVP_PKEY_decrypt_init =
      _EVP_PKEY_decrypt_init_ptr.asFunction<_dart_EVP_PKEY_decrypt_init>();

  /// EVP_PKEY_encrypt encrypts |in_len| bytes from |in|. If |out| is NULL, the
  /// maximum size of the ciphertext is written to |out_len|. Otherwise, |*out_len|
  /// must contain the number of bytes of space available at |out|. If sufficient,
  /// the ciphertext will be written to |out| and |*out_len| updated with the true
  /// length.
  ///
  /// WARNING: Setting |out| to NULL only gives the maximum size of the
  /// ciphertext. The actual ciphertext may be smaller.
  ///
  /// It returns one on success or zero on error.
  int EVP_PKEY_encrypt(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.IntPtr> out_len,
    ffi.Pointer<ffi.Uint8> in_1,
    int in_len,
  ) {
    return _EVP_PKEY_encrypt(
      ctx,
      out,
      out_len,
      in_1,
      in_len,
    );
  }

  late final _EVP_PKEY_encrypt_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_encrypt>>('EVP_PKEY_encrypt');
  late final _dart_EVP_PKEY_encrypt _EVP_PKEY_encrypt =
      _EVP_PKEY_encrypt_ptr.asFunction<_dart_EVP_PKEY_encrypt>();

  /// EVP_PKEY_encrypt_init initialises an |EVP_PKEY_CTX| for an encryption
  /// operation. It should be called before |EVP_PKEY_encrypt|.
  ///
  /// It returns one on success or zero on error.
  int EVP_PKEY_encrypt_init(
    ffi.Pointer<EVP_PKEY_CTX> ctx,
  ) {
    return _EVP_PKEY_encrypt_init(
      ctx,
    );
  }

  late final _EVP_PKEY_encrypt_init_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_encrypt_init>>(
          'EVP_PKEY_encrypt_init');
  late final _dart_EVP_PKEY_encrypt_init _EVP_PKEY_encrypt_init =
      _EVP_PKEY_encrypt_init_ptr.asFunction<_dart_EVP_PKEY_encrypt_init>();

  /// EVP_PKEY_free frees all data referenced by |pkey| and then frees |pkey|
  /// itself.
  void EVP_PKEY_free(
    ffi.Pointer<EVP_PKEY> pkey,
  ) {
    return _EVP_PKEY_free(
      pkey,
    );
  }

  late final _EVP_PKEY_free_ptr =
      _lookup<ffi.NativeFunction<Native_EVP_PKEY_free>>('EVP_PKEY_free');
  late final _dart_EVP_PKEY_free _EVP_PKEY_free =
      _EVP_PKEY_free_ptr.asFunction<_dart_EVP_PKEY_free>();

  ffi.Pointer<EC_KEY> EVP_PKEY_get1_EC_KEY(
    ffi.Pointer<EVP_PKEY> pkey,
  ) {
    return _EVP_PKEY_get1_EC_KEY(
      pkey,
    );
  }

  late final _EVP_PKEY_get1_EC_KEY_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_get1_EC_KEY>>(
          'EVP_PKEY_get1_EC_KEY');
  late final _dart_EVP_PKEY_get1_EC_KEY _EVP_PKEY_get1_EC_KEY =
      _EVP_PKEY_get1_EC_KEY_ptr.asFunction<_dart_EVP_PKEY_get1_EC_KEY>();

  ffi.Pointer<RSA> EVP_PKEY_get1_RSA(
    ffi.Pointer<EVP_PKEY> pkey,
  ) {
    return _EVP_PKEY_get1_RSA(
      pkey,
    );
  }

  late final _EVP_PKEY_get1_RSA_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_get1_RSA>>('EVP_PKEY_get1_RSA');
  late final _dart_EVP_PKEY_get1_RSA _EVP_PKEY_get1_RSA =
      _EVP_PKEY_get1_RSA_ptr.asFunction<_dart_EVP_PKEY_get1_RSA>();

  /// EVP_PKEY_id returns the type of |pkey|, which is one of the |EVP_PKEY_*|
  /// values.
  int EVP_PKEY_id(
    ffi.Pointer<EVP_PKEY> pkey,
  ) {
    return _EVP_PKEY_id(
      pkey,
    );
  }

  late final _EVP_PKEY_id_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_id>>('EVP_PKEY_id');
  late final _dart_EVP_PKEY_id _EVP_PKEY_id =
      _EVP_PKEY_id_ptr.asFunction<_dart_EVP_PKEY_id>();

  /// EVP_PKEY_new creates a new, empty public-key object and returns it or NULL
  /// on allocation failure.
  ffi.Pointer<EVP_PKEY> EVP_PKEY_new() {
    return _EVP_PKEY_new();
  }

  late final _EVP_PKEY_new_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_new>>('EVP_PKEY_new');
  late final _dart_EVP_PKEY_new _EVP_PKEY_new =
      _EVP_PKEY_new_ptr.asFunction<_dart_EVP_PKEY_new>();

  int EVP_PKEY_set1_EC_KEY(
    ffi.Pointer<EVP_PKEY> pkey,
    ffi.Pointer<EC_KEY> key,
  ) {
    return _EVP_PKEY_set1_EC_KEY(
      pkey,
      key,
    );
  }

  late final _EVP_PKEY_set1_EC_KEY_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_set1_EC_KEY>>(
          'EVP_PKEY_set1_EC_KEY');
  late final _dart_EVP_PKEY_set1_EC_KEY _EVP_PKEY_set1_EC_KEY =
      _EVP_PKEY_set1_EC_KEY_ptr.asFunction<_dart_EVP_PKEY_set1_EC_KEY>();

  /// Getting and setting concrete public key types.
  ///
  /// The following functions get and set the underlying public key in an
  /// |EVP_PKEY| object. The |set1| functions take an additional reference to the
  /// underlying key and return one on success or zero if |key| is NULL. The
  /// |assign| functions adopt the caller's reference and return one on success or
  /// zero if |key| is NULL. The |get1| functions return a fresh reference to the
  /// underlying object or NULL if |pkey| is not of the correct type. The |get0|
  /// functions behave the same but return a non-owning pointer.
  ///
  /// The |get0| and |get1| functions take |const| pointers and are thus
  /// non-mutating for thread-safety purposes, but mutating functions on the
  /// returned lower-level objects are considered to also mutate the |EVP_PKEY| and
  /// may not be called concurrently with other operations on the |EVP_PKEY|.
  int EVP_PKEY_set1_RSA(
    ffi.Pointer<EVP_PKEY> pkey,
    ffi.Pointer<RSA> key,
  ) {
    return _EVP_PKEY_set1_RSA(
      pkey,
      key,
    );
  }

  late final _EVP_PKEY_set1_RSA_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_set1_RSA>>('EVP_PKEY_set1_RSA');
  late final _dart_EVP_PKEY_set1_RSA _EVP_PKEY_set1_RSA =
      _EVP_PKEY_set1_RSA_ptr.asFunction<_dart_EVP_PKEY_set1_RSA>();

  /// EVP_PKEY_set_type sets the type of |pkey| to |type|. It returns one if
  /// successful or zero if the |type| argument is not one of the |EVP_PKEY_*|
  /// values. If |pkey| is NULL, it simply reports whether the type is known.
  int EVP_PKEY_set_type(
    ffi.Pointer<EVP_PKEY> pkey,
    int type,
  ) {
    return _EVP_PKEY_set_type(
      pkey,
      type,
    );
  }

  late final _EVP_PKEY_set_type_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_PKEY_set_type>>('EVP_PKEY_set_type');
  late final _dart_EVP_PKEY_set_type _EVP_PKEY_set_type =
      _EVP_PKEY_set_type_ptr.asFunction<_dart_EVP_PKEY_set_type>();

  /// EVP_aead_aes_128_gcm is AES-128 in Galois Counter Mode.
  ///
  /// Note: AES-GCM should only be used with 12-byte (96-bit) nonces. Although it
  /// is specified to take a variable-length nonce, nonces with other lengths are
  /// effectively randomized, which means one must consider collisions. Unless
  /// implementing an existing protocol which has already specified incorrect
  /// parameters, only use 12-byte nonces.
  ffi.Pointer<EVP_AEAD> EVP_aead_aes_128_gcm() {
    return _EVP_aead_aes_128_gcm();
  }

  late final _EVP_aead_aes_128_gcm_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_aead_aes_128_gcm>>(
          'EVP_aead_aes_128_gcm');
  late final _dart_EVP_aead_aes_128_gcm _EVP_aead_aes_128_gcm =
      _EVP_aead_aes_128_gcm_ptr.asFunction<_dart_EVP_aead_aes_128_gcm>();

  /// EVP_aead_aes_256_gcm is AES-256 in Galois Counter Mode.
  ///
  /// Note: AES-GCM should only be used with 12-byte (96-bit) nonces. Although it
  /// is specified to take a variable-length nonce, nonces with other lengths are
  /// effectively randomized, which means one must consider collisions. Unless
  /// implementing an existing protocol which has already specified incorrect
  /// parameters, only use 12-byte nonces.
  ffi.Pointer<EVP_AEAD> EVP_aead_aes_256_gcm() {
    return _EVP_aead_aes_256_gcm();
  }

  late final _EVP_aead_aes_256_gcm_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_aead_aes_256_gcm>>(
          'EVP_aead_aes_256_gcm');
  late final _dart_EVP_aead_aes_256_gcm _EVP_aead_aes_256_gcm =
      _EVP_aead_aes_256_gcm_ptr.asFunction<_dart_EVP_aead_aes_256_gcm>();

  ffi.Pointer<EVP_CIPHER> EVP_aes_128_cbc() {
    return _EVP_aes_128_cbc();
  }

  late final _EVP_aes_128_cbc_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_aes_128_cbc>>('EVP_aes_128_cbc');
  late final _dart_EVP_aes_128_cbc _EVP_aes_128_cbc =
      _EVP_aes_128_cbc_ptr.asFunction<_dart_EVP_aes_128_cbc>();

  ffi.Pointer<EVP_CIPHER> EVP_aes_128_ctr() {
    return _EVP_aes_128_ctr();
  }

  late final _EVP_aes_128_ctr_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_aes_128_ctr>>('EVP_aes_128_ctr');
  late final _dart_EVP_aes_128_ctr _EVP_aes_128_ctr =
      _EVP_aes_128_ctr_ptr.asFunction<_dart_EVP_aes_128_ctr>();

  ffi.Pointer<EVP_CIPHER> EVP_aes_256_cbc() {
    return _EVP_aes_256_cbc();
  }

  late final _EVP_aes_256_cbc_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_aes_256_cbc>>('EVP_aes_256_cbc');
  late final _dart_EVP_aes_256_cbc _EVP_aes_256_cbc =
      _EVP_aes_256_cbc_ptr.asFunction<_dart_EVP_aes_256_cbc>();

  ffi.Pointer<EVP_CIPHER> EVP_aes_256_ctr() {
    return _EVP_aes_256_ctr();
  }

  late final _EVP_aes_256_ctr_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_aes_256_ctr>>('EVP_aes_256_ctr');
  late final _dart_EVP_aes_256_ctr _EVP_aes_256_ctr =
      _EVP_aes_256_ctr_ptr.asFunction<_dart_EVP_aes_256_ctr>();

  /// EVP_marshal_private_key marshals |key| as a DER-encoded PrivateKeyInfo
  /// structure (RFC 5208) and appends the result to |cbb|. It returns one on
  /// success and zero on error.
  int EVP_marshal_private_key(
    ffi.Pointer<CBB> cbb,
    ffi.Pointer<EVP_PKEY> key,
  ) {
    return _EVP_marshal_private_key(
      cbb,
      key,
    );
  }

  late final _EVP_marshal_private_key_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_marshal_private_key>>(
          'EVP_marshal_private_key');
  late final _dart_EVP_marshal_private_key _EVP_marshal_private_key =
      _EVP_marshal_private_key_ptr.asFunction<_dart_EVP_marshal_private_key>();

  /// EVP_marshal_public_key marshals |key| as a DER-encoded SubjectPublicKeyInfo
  /// structure (RFC 5280) and appends the result to |cbb|. It returns one on
  /// success and zero on error.
  int EVP_marshal_public_key(
    ffi.Pointer<CBB> cbb,
    ffi.Pointer<EVP_PKEY> key,
  ) {
    return _EVP_marshal_public_key(
      cbb,
      key,
    );
  }

  late final _EVP_marshal_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_marshal_public_key>>(
          'EVP_marshal_public_key');
  late final _dart_EVP_marshal_public_key _EVP_marshal_public_key =
      _EVP_marshal_public_key_ptr.asFunction<_dart_EVP_marshal_public_key>();

  /// EVP_parse_private_key decodes a DER-encoded PrivateKeyInfo structure (RFC
  /// 5208) from |cbs| and advances |cbs|. It returns a newly-allocated |EVP_PKEY|
  /// or NULL on error.
  ///
  /// The caller must check the type of the parsed private key to ensure it is
  /// suitable and validate other desired key properties such as RSA modulus size
  /// or EC curve.
  ///
  /// A PrivateKeyInfo ends with an optional set of attributes. These are not
  /// processed and so this function will silently ignore any trailing data in the
  /// structure.
  ffi.Pointer<EVP_PKEY> EVP_parse_private_key(
    ffi.Pointer<CBS> cbs,
  ) {
    return _EVP_parse_private_key(
      cbs,
    );
  }

  late final _EVP_parse_private_key_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_parse_private_key>>(
          'EVP_parse_private_key');
  late final _dart_EVP_parse_private_key _EVP_parse_private_key =
      _EVP_parse_private_key_ptr.asFunction<_dart_EVP_parse_private_key>();

  /// EVP_parse_public_key decodes a DER-encoded SubjectPublicKeyInfo structure
  /// (RFC 5280) from |cbs| and advances |cbs|. It returns a newly-allocated
  /// |EVP_PKEY| or NULL on error. If the key is an EC key, the curve is guaranteed
  /// to be set.
  ///
  /// The caller must check the type of the parsed public key to ensure it is
  /// suitable and validate other desired key properties such as RSA modulus size
  /// or EC curve.
  ffi.Pointer<EVP_PKEY> EVP_parse_public_key(
    ffi.Pointer<CBS> cbs,
  ) {
    return _EVP_parse_public_key(
      cbs,
    );
  }

  late final _EVP_parse_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_parse_public_key>>(
          'EVP_parse_public_key');
  late final _dart_EVP_parse_public_key _EVP_parse_public_key =
      _EVP_parse_public_key_ptr.asFunction<_dart_EVP_parse_public_key>();

  ffi.Pointer<EVP_MD> EVP_sha1() {
    return _EVP_sha1();
  }

  late final _EVP_sha1_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_sha1>>('EVP_sha1');
  late final _dart_EVP_sha1 _EVP_sha1 =
      _EVP_sha1_ptr.asFunction<_dart_EVP_sha1>();

  ffi.Pointer<EVP_MD> EVP_sha256() {
    return _EVP_sha256();
  }

  late final _EVP_sha256_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_sha256>>('EVP_sha256');
  late final _dart_EVP_sha256 _EVP_sha256 =
      _EVP_sha256_ptr.asFunction<_dart_EVP_sha256>();

  ffi.Pointer<EVP_MD> EVP_sha384() {
    return _EVP_sha384();
  }

  late final _EVP_sha384_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_sha384>>('EVP_sha384');
  late final _dart_EVP_sha384 _EVP_sha384 =
      _EVP_sha384_ptr.asFunction<_dart_EVP_sha384>();

  ffi.Pointer<EVP_MD> EVP_sha512() {
    return _EVP_sha512();
  }

  late final _EVP_sha512_ptr =
      _lookup<ffi.NativeFunction<_c_EVP_sha512>>('EVP_sha512');
  late final _dart_EVP_sha512 _EVP_sha512 =
      _EVP_sha512_ptr.asFunction<_dart_EVP_sha512>();

  late final ffi.Pointer<ASN1_ITEM_st> _EXTENDED_KEY_USAGE_it =
      _lookup<ASN1_ITEM_st>('EXTENDED_KEY_USAGE_it');

  ffi.Pointer<ASN1_ITEM_st> get EXTENDED_KEY_USAGE_it => _EXTENDED_KEY_USAGE_it;

  late final ffi.Pointer<ASN1_ITEM_st> _GENERAL_NAMES_it =
      _lookup<ASN1_ITEM_st>('GENERAL_NAMES_it');

  ffi.Pointer<ASN1_ITEM_st> get GENERAL_NAMES_it => _GENERAL_NAMES_it;

  late final ffi.Pointer<ASN1_ITEM_st> _GENERAL_NAME_it =
      _lookup<ASN1_ITEM_st>('GENERAL_NAME_it');

  ffi.Pointer<ASN1_ITEM_st> get GENERAL_NAME_it => _GENERAL_NAME_it;

  late final ffi.Pointer<ASN1_ITEM_st> _GENERAL_SUBTREE_it =
      _lookup<ASN1_ITEM_st>('GENERAL_SUBTREE_it');

  ffi.Pointer<ASN1_ITEM_st> get GENERAL_SUBTREE_it => _GENERAL_SUBTREE_it;

  /// HKDF computes HKDF (as specified by RFC 5869) of initial keying material
  /// |secret| with |salt| and |info| using |digest|, and outputs |out_len| bytes
  /// to |out_key|. It returns one on success and zero on error.
  ///
  /// HKDF is an Extract-and-Expand algorithm. It does not do any key stretching,
  /// and as such, is not suited to be used alone to generate a key from a
  /// password.
  int HKDF(
    ffi.Pointer<ffi.Uint8> out_key,
    int out_len,
    ffi.Pointer<EVP_MD> digest,
    ffi.Pointer<ffi.Uint8> secret,
    int secret_len,
    ffi.Pointer<ffi.Uint8> salt,
    int salt_len,
    ffi.Pointer<ffi.Uint8> info,
    int info_len,
  ) {
    return _HKDF(
      out_key,
      out_len,
      digest,
      secret,
      secret_len,
      salt,
      salt_len,
      info,
      info_len,
    );
  }

  late final _HKDF_ptr = _lookup<ffi.NativeFunction<_c_HKDF>>('HKDF');
  late final _dart_HKDF _HKDF = _HKDF_ptr.asFunction<_dart_HKDF>();

  /// HMAC_CTX_free calls |HMAC_CTX_cleanup| and then frees |ctx| itself.
  void HMAC_CTX_free(
    ffi.Pointer<HMAC_CTX> ctx,
  ) {
    return _HMAC_CTX_free(
      ctx,
    );
  }

  late final _HMAC_CTX_free_ptr =
      _lookup<ffi.NativeFunction<_c_HMAC_CTX_free>>('HMAC_CTX_free');
  late final _dart_HMAC_CTX_free _HMAC_CTX_free =
      _HMAC_CTX_free_ptr.asFunction<_dart_HMAC_CTX_free>();

  /// HMAC_CTX_new allocates and initialises a new |HMAC_CTX| and returns it, or
  /// NULL on allocation failure. The caller must use |HMAC_CTX_free| to release
  /// the resulting object.
  ffi.Pointer<HMAC_CTX> HMAC_CTX_new() {
    return _HMAC_CTX_new();
  }

  late final _HMAC_CTX_new_ptr =
      _lookup<ffi.NativeFunction<_c_HMAC_CTX_new>>('HMAC_CTX_new');
  late final _dart_HMAC_CTX_new _HMAC_CTX_new =
      _HMAC_CTX_new_ptr.asFunction<_dart_HMAC_CTX_new>();

  /// HMAC_Final completes the HMAC operation in |ctx| and writes the result to
  /// |out| and the sets |*out_len| to the length of the result. On entry, |out|
  /// must contain at least |HMAC_size| bytes of space. An output size of
  /// |EVP_MAX_MD_SIZE| will always be large enough. It returns one on success or
  /// zero on allocation failure.
  int HMAC_Final(
    ffi.Pointer<HMAC_CTX> ctx,
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Uint32> out_len,
  ) {
    return _HMAC_Final(
      ctx,
      out,
      out_len,
    );
  }

  late final _HMAC_Final_ptr =
      _lookup<ffi.NativeFunction<_c_HMAC_Final>>('HMAC_Final');
  late final _dart_HMAC_Final _HMAC_Final =
      _HMAC_Final_ptr.asFunction<_dart_HMAC_Final>();

  /// HMAC_Init_ex sets up an initialised |HMAC_CTX| to use |md| as the hash
  /// function and |key| as the key. For a non-initial call, |md| may be NULL, in
  /// which case the previous hash function will be used. If the hash function has
  /// not changed and |key| is NULL, |ctx| reuses the previous key. It returns one
  /// on success or zero on allocation failure.
  ///
  /// WARNING: NULL and empty keys are ambiguous on non-initial calls. Passing NULL
  /// |key| but repeating the previous |md| reuses the previous key rather than the
  /// empty key.
  int HMAC_Init_ex(
    ffi.Pointer<HMAC_CTX> ctx,
    ffi.Pointer<ffi.Void> key,
    int key_len,
    ffi.Pointer<EVP_MD> md,
    ffi.Pointer<ENGINE> impl,
  ) {
    return _HMAC_Init_ex(
      ctx,
      key,
      key_len,
      md,
      impl,
    );
  }

  late final _HMAC_Init_ex_ptr =
      _lookup<ffi.NativeFunction<_c_HMAC_Init_ex>>('HMAC_Init_ex');
  late final _dart_HMAC_Init_ex _HMAC_Init_ex =
      _HMAC_Init_ex_ptr.asFunction<_dart_HMAC_Init_ex>();

  /// HMAC_Update hashes |data_len| bytes from |data| into the current HMAC
  /// operation in |ctx|. It returns one.
  int HMAC_Update(
    ffi.Pointer<HMAC_CTX> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int data_len,
  ) {
    return _HMAC_Update(
      ctx,
      data,
      data_len,
    );
  }

  late final _HMAC_Update_ptr =
      _lookup<ffi.NativeFunction<_c_HMAC_Update>>('HMAC_Update');
  late final _dart_HMAC_Update _HMAC_Update =
      _HMAC_Update_ptr.asFunction<_dart_HMAC_Update>();

  /// HMAC_size returns the size, in bytes, of the HMAC that will be produced by
  /// |ctx|. On entry, |ctx| must have been setup with |HMAC_Init_ex|.
  int HMAC_size(
    ffi.Pointer<HMAC_CTX> ctx,
  ) {
    return _HMAC_size(
      ctx,
    );
  }

  late final _HMAC_size_ptr =
      _lookup<ffi.NativeFunction<_c_HMAC_size>>('HMAC_size');
  late final _dart_HMAC_size _HMAC_size =
      _HMAC_size_ptr.asFunction<_dart_HMAC_size>();

  late final ffi.Pointer<ASN1_ITEM_st> _ISSUING_DIST_POINT_it =
      _lookup<ASN1_ITEM_st>('ISSUING_DIST_POINT_it');

  ffi.Pointer<ASN1_ITEM_st> get ISSUING_DIST_POINT_it => _ISSUING_DIST_POINT_it;

  late final ffi.Pointer<ASN1_ITEM_st> _NAME_CONSTRAINTS_it =
      _lookup<ASN1_ITEM_st>('NAME_CONSTRAINTS_it');

  ffi.Pointer<ASN1_ITEM_st> get NAME_CONSTRAINTS_it => _NAME_CONSTRAINTS_it;

  late final ffi.Pointer<ASN1_ITEM_st> _NETSCAPE_SPKAC_it =
      _lookup<ASN1_ITEM_st>('NETSCAPE_SPKAC_it');

  ffi.Pointer<ASN1_ITEM_st> get NETSCAPE_SPKAC_it => _NETSCAPE_SPKAC_it;

  late final ffi.Pointer<ASN1_ITEM_st> _NETSCAPE_SPKI_it =
      _lookup<ASN1_ITEM_st>('NETSCAPE_SPKI_it');

  ffi.Pointer<ASN1_ITEM_st> get NETSCAPE_SPKI_it => _NETSCAPE_SPKI_it;

  late final ffi.Pointer<ASN1_ITEM_st> _NOTICEREF_it =
      _lookup<ASN1_ITEM_st>('NOTICEREF_it');

  ffi.Pointer<ASN1_ITEM_st> get NOTICEREF_it => _NOTICEREF_it;

  /// OPENSSL_free does nothing if |ptr| is NULL. Otherwise it zeros out the
  /// memory allocated at |ptr| and frees it.
  void OPENSSL_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _OPENSSL_free(
      ptr,
    );
  }

  late final _OPENSSL_free_ptr =
      _lookup<ffi.NativeFunction<_c_OPENSSL_free>>('OPENSSL_free');
  late final _dart_OPENSSL_free _OPENSSL_free =
      _OPENSSL_free_ptr.asFunction<_dart_OPENSSL_free>();

  /// OPENSSL_ia32cap_P contains the Intel CPUID bits when running on an x86 or
  /// x86-64 system.
  ///
  /// Index 0:
  /// EDX for CPUID where EAX = 1
  /// Bit 20 is always zero
  /// Bit 28 is adjusted to reflect whether the data cache is shared between
  /// multiple logical cores
  /// Bit 30 is used to indicate an Intel CPU
  /// Index 1:
  /// ECX for CPUID where EAX = 1
  /// Bit 11 is used to indicate AMD XOP support, not SDBG
  /// Index 2:
  /// EBX for CPUID where EAX = 7
  /// Index 3:
  /// ECX for CPUID where EAX = 7
  ///
  /// Note: the CPUID bits are pre-adjusted for the OSXSAVE bit and the YMM and XMM
  /// bits in XCR0, so it is not necessary to check those.
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _OPENSSL_ia32cap_P =
      _lookup<ffi.Pointer<ffi.Uint32>>('OPENSSL_ia32cap_P');

  ffi.Pointer<ffi.Uint32> get OPENSSL_ia32cap_P => _OPENSSL_ia32cap_P.value;

  set OPENSSL_ia32cap_P(ffi.Pointer<ffi.Uint32> value) =>
      _OPENSSL_ia32cap_P.value = value;

  /// OPENSSL_malloc acts like a regular |malloc|.
  ffi.Pointer<ffi.Void> OPENSSL_malloc(
    int size,
  ) {
    return _OPENSSL_malloc(
      size,
    );
  }

  late final _OPENSSL_malloc_ptr =
      _lookup<ffi.NativeFunction<_c_OPENSSL_malloc>>('OPENSSL_malloc');
  late final _dart_OPENSSL_malloc _OPENSSL_malloc =
      _OPENSSL_malloc_ptr.asFunction<_dart_OPENSSL_malloc>();

  /// OPENSSL_memdup returns an allocated, duplicate of |size| bytes from |data| or
  /// NULL on allocation failure.
  ffi.Pointer<ffi.Void> OPENSSL_memdup(
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _OPENSSL_memdup(
      data,
      size,
    );
  }

  late final _OPENSSL_memdup_ptr =
      _lookup<ffi.NativeFunction<_c_OPENSSL_memdup>>('OPENSSL_memdup');
  late final _dart_OPENSSL_memdup _OPENSSL_memdup =
      _OPENSSL_memdup_ptr.asFunction<_dart_OPENSSL_memdup>();

  late final ffi.Pointer<ASN1_ITEM_st> _OTHERNAME_it =
      _lookup<ASN1_ITEM_st>('OTHERNAME_it');

  ffi.Pointer<ASN1_ITEM_st> get OTHERNAME_it => _OTHERNAME_it;

  /// PKCS5_PBKDF2_HMAC computes |iterations| iterations of PBKDF2 of |password|
  /// and |salt|, using |digest|, and outputs |key_len| bytes to |out_key|. It
  /// returns one on success and zero on allocation failure or if iterations is 0.
  int PKCS5_PBKDF2_HMAC(
    ffi.Pointer<ffi.Int8> password,
    int password_len,
    ffi.Pointer<ffi.Uint8> salt,
    int salt_len,
    int iterations,
    ffi.Pointer<EVP_MD> digest,
    int key_len,
    ffi.Pointer<ffi.Uint8> out_key,
  ) {
    return _PKCS5_PBKDF2_HMAC(
      password,
      password_len,
      salt,
      salt_len,
      iterations,
      digest,
      key_len,
      out_key,
    );
  }

  late final _PKCS5_PBKDF2_HMAC_ptr =
      _lookup<ffi.NativeFunction<_c_PKCS5_PBKDF2_HMAC>>('PKCS5_PBKDF2_HMAC');
  late final _dart_PKCS5_PBKDF2_HMAC _PKCS5_PBKDF2_HMAC =
      _PKCS5_PBKDF2_HMAC_ptr.asFunction<_dart_PKCS5_PBKDF2_HMAC>();

  late final ffi.Pointer<ASN1_ITEM_st> _PKCS8_PRIV_KEY_INFO_it =
      _lookup<ASN1_ITEM_st>('PKCS8_PRIV_KEY_INFO_it');

  ffi.Pointer<ASN1_ITEM_st> get PKCS8_PRIV_KEY_INFO_it =>
      _PKCS8_PRIV_KEY_INFO_it;

  late final ffi.Pointer<ASN1_ITEM_st> _PKEY_USAGE_PERIOD_it =
      _lookup<ASN1_ITEM_st>('PKEY_USAGE_PERIOD_it');

  ffi.Pointer<ASN1_ITEM_st> get PKEY_USAGE_PERIOD_it => _PKEY_USAGE_PERIOD_it;

  late final ffi.Pointer<ASN1_ITEM_st> _POLICYINFO_it =
      _lookup<ASN1_ITEM_st>('POLICYINFO_it');

  ffi.Pointer<ASN1_ITEM_st> get POLICYINFO_it => _POLICYINFO_it;

  late final ffi.Pointer<ASN1_ITEM_st> _POLICYQUALINFO_it =
      _lookup<ASN1_ITEM_st>('POLICYQUALINFO_it');

  ffi.Pointer<ASN1_ITEM_st> get POLICYQUALINFO_it => _POLICYQUALINFO_it;

  late final ffi.Pointer<ASN1_ITEM_st> _POLICY_CONSTRAINTS_it =
      _lookup<ASN1_ITEM_st>('POLICY_CONSTRAINTS_it');

  ffi.Pointer<ASN1_ITEM_st> get POLICY_CONSTRAINTS_it => _POLICY_CONSTRAINTS_it;

  late final ffi.Pointer<ASN1_ITEM_st> _POLICY_MAPPINGS_it =
      _lookup<ASN1_ITEM_st>('POLICY_MAPPINGS_it');

  ffi.Pointer<ASN1_ITEM_st> get POLICY_MAPPINGS_it => _POLICY_MAPPINGS_it;

  late final ffi.Pointer<ASN1_ITEM_st> _POLICY_MAPPING_it =
      _lookup<ASN1_ITEM_st>('POLICY_MAPPING_it');

  ffi.Pointer<ASN1_ITEM_st> get POLICY_MAPPING_it => _POLICY_MAPPING_it;

  late final ffi.Pointer<ASN1_ITEM_st> _PROXY_CERT_INFO_EXTENSION_it =
      _lookup<ASN1_ITEM_st>('PROXY_CERT_INFO_EXTENSION_it');

  ffi.Pointer<ASN1_ITEM_st> get PROXY_CERT_INFO_EXTENSION_it =>
      _PROXY_CERT_INFO_EXTENSION_it;

  late final ffi.Pointer<ASN1_ITEM_st> _PROXY_POLICY_it =
      _lookup<ASN1_ITEM_st>('PROXY_POLICY_it');

  ffi.Pointer<ASN1_ITEM_st> get PROXY_POLICY_it => _PROXY_POLICY_it;

  /// RAND_bytes writes |len| bytes of random data to |buf| and returns one.
  int RAND_bytes(
    ffi.Pointer<ffi.Uint8> buf,
    int len,
  ) {
    return _RAND_bytes(
      buf,
      len,
    );
  }

  late final _RAND_bytes_ptr =
      _lookup<ffi.NativeFunction<_c_RAND_bytes>>('RAND_bytes');
  late final _dart_RAND_bytes _RAND_bytes =
      _RAND_bytes_ptr.asFunction<_dart_RAND_bytes>();

  /// RSAPublicKey_dup allocates a fresh |RSA| and copies the public key from
  /// |rsa| into it. It returns the fresh |RSA| object, or NULL on error.
  ffi.Pointer<RSA> RSAPublicKey_dup(
    ffi.Pointer<RSA> rsa,
  ) {
    return _RSAPublicKey_dup(
      rsa,
    );
  }

  late final _RSAPublicKey_dup_ptr =
      _lookup<ffi.NativeFunction<_c_RSAPublicKey_dup>>('RSAPublicKey_dup');
  late final _dart_RSAPublicKey_dup _RSAPublicKey_dup =
      _RSAPublicKey_dup_ptr.asFunction<_dart_RSAPublicKey_dup>();

  late final ffi.Pointer<ASN1_ITEM_st> _RSA_PSS_PARAMS_it =
      _lookup<ASN1_ITEM_st>('RSA_PSS_PARAMS_it');

  ffi.Pointer<ASN1_ITEM_st> get RSA_PSS_PARAMS_it => _RSA_PSS_PARAMS_it;

  /// RSA_check_key performs basic validity tests on |rsa|. It returns one if
  /// they pass and zero otherwise. Opaque keys and public keys always pass. If it
  /// returns zero then a more detailed error is available on the error queue.
  int RSA_check_key(
    ffi.Pointer<RSA> rsa,
  ) {
    return _RSA_check_key(
      rsa,
    );
  }

  late final _RSA_check_key_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_check_key>>('RSA_check_key');
  late final _dart_RSA_check_key _RSA_check_key =
      _RSA_check_key_ptr.asFunction<_dart_RSA_check_key>();

  /// RSA_free decrements the reference count of |rsa| and frees it if the
  /// reference count drops to zero.
  void RSA_free(
    ffi.Pointer<RSA> rsa,
  ) {
    return _RSA_free(
      rsa,
    );
  }

  late final _RSA_free_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_free>>('RSA_free');
  late final _dart_RSA_free _RSA_free =
      _RSA_free_ptr.asFunction<_dart_RSA_free>();

  /// RSA_generate_key_ex generates a new RSA key where the modulus has size
  /// |bits| and the public exponent is |e|. If unsure, |RSA_F4| is a good value
  /// for |e|. If |cb| is not NULL then it is called during the key generation
  /// process. In addition to the calls documented for |BN_generate_prime_ex|, it
  /// is called with event=2 when the n'th prime is rejected as unsuitable and
  /// with event=3 when a suitable value for |p| is found.
  ///
  /// It returns one on success or zero on error.
  int RSA_generate_key_ex(
    ffi.Pointer<RSA> rsa,
    int bits,
    ffi.Pointer<BIGNUM> e,
    ffi.Pointer<BN_GENCB> cb,
  ) {
    return _RSA_generate_key_ex(
      rsa,
      bits,
      e,
      cb,
    );
  }

  late final _RSA_generate_key_ex_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_generate_key_ex>>(
          'RSA_generate_key_ex');
  late final _dart_RSA_generate_key_ex _RSA_generate_key_ex =
      _RSA_generate_key_ex_ptr.asFunction<_dart_RSA_generate_key_ex>();

  /// RSA_get0_crt_params sets |*out_dmp1|, |*out_dmq1|, and |*out_iqmp|, if
  /// non-NULL, to |rsa|'s CRT parameters. These are d (mod p-1), d (mod q-1) and
  /// q^-1 (mod p), respectively. If |rsa| is a public key, each parameter will be
  /// set to NULL.
  void RSA_get0_crt_params(
    ffi.Pointer<RSA> rsa,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_dmp1,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_dmq1,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_iqmp,
  ) {
    return _RSA_get0_crt_params(
      rsa,
      out_dmp1,
      out_dmq1,
      out_iqmp,
    );
  }

  late final _RSA_get0_crt_params_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_get0_crt_params>>(
          'RSA_get0_crt_params');
  late final _dart_RSA_get0_crt_params _RSA_get0_crt_params =
      _RSA_get0_crt_params_ptr.asFunction<_dart_RSA_get0_crt_params>();

  /// RSA_get0_factors sets |*out_p| and |*out_q|, if non-NULL, to |rsa|'s prime
  /// factors. If |rsa| is a public key, they will be set to NULL.
  void RSA_get0_factors(
    ffi.Pointer<RSA> rsa,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_p,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_q,
  ) {
    return _RSA_get0_factors(
      rsa,
      out_p,
      out_q,
    );
  }

  late final _RSA_get0_factors_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_get0_factors>>('RSA_get0_factors');
  late final _dart_RSA_get0_factors _RSA_get0_factors =
      _RSA_get0_factors_ptr.asFunction<_dart_RSA_get0_factors>();

  /// RSA_get0_key sets |*out_n|, |*out_e|, and |*out_d|, if non-NULL, to |rsa|'s
  /// modulus, public exponent, and private exponent, respectively. If |rsa| is a
  /// public key, the private exponent will be set to NULL.
  void RSA_get0_key(
    ffi.Pointer<RSA> rsa,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_n,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_e,
    ffi.Pointer<ffi.Pointer<BIGNUM>> out_d,
  ) {
    return _RSA_get0_key(
      rsa,
      out_n,
      out_e,
      out_d,
    );
  }

  late final _RSA_get0_key_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_get0_key>>('RSA_get0_key');
  late final _dart_RSA_get0_key _RSA_get0_key =
      _RSA_get0_key_ptr.asFunction<_dart_RSA_get0_key>();

  /// RSA_new returns a new, empty |RSA| object or NULL on error.
  ffi.Pointer<RSA> RSA_new() {
    return _RSA_new();
  }

  late final _RSA_new_ptr = _lookup<ffi.NativeFunction<_c_RSA_new>>('RSA_new');
  late final _dart_RSA_new _RSA_new = _RSA_new_ptr.asFunction<_dart_RSA_new>();

  /// RSA_set0_crt_params sets |rsa|'s CRT parameters to |dmp1|, |dmq1|, and
  /// |iqmp|, if non-NULL, and takes ownership of them. On success, it takes
  /// ownership of its parameters and returns one. Otherwise, it returns zero.
  ///
  /// Each argument must either be non-NULL or already configured on |rsa|.
  ///
  /// It is an error to call this function after |rsa| has been used for a
  /// cryptographic operation. Construct a new |RSA| object instead.
  int RSA_set0_crt_params(
    ffi.Pointer<RSA> rsa,
    ffi.Pointer<BIGNUM> dmp1,
    ffi.Pointer<BIGNUM> dmq1,
    ffi.Pointer<BIGNUM> iqmp,
  ) {
    return _RSA_set0_crt_params(
      rsa,
      dmp1,
      dmq1,
      iqmp,
    );
  }

  late final _RSA_set0_crt_params_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_set0_crt_params>>(
          'RSA_set0_crt_params');
  late final _dart_RSA_set0_crt_params _RSA_set0_crt_params =
      _RSA_set0_crt_params_ptr.asFunction<_dart_RSA_set0_crt_params>();

  /// RSA_set0_factors sets |rsa|'s prime factors to |p| and |q|, if non-NULL, and
  /// takes ownership of them. On success, it takes ownership of each argument and
  /// returns one. Otherwise, it returns zero.
  ///
  /// Each argument must either be non-NULL or already configured on |rsa|.
  ///
  /// It is an error to call this function after |rsa| has been used for a
  /// cryptographic operation. Construct a new |RSA| object instead.
  int RSA_set0_factors(
    ffi.Pointer<RSA> rsa,
    ffi.Pointer<BIGNUM> p,
    ffi.Pointer<BIGNUM> q,
  ) {
    return _RSA_set0_factors(
      rsa,
      p,
      q,
    );
  }

  late final _RSA_set0_factors_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_set0_factors>>('RSA_set0_factors');
  late final _dart_RSA_set0_factors _RSA_set0_factors =
      _RSA_set0_factors_ptr.asFunction<_dart_RSA_set0_factors>();

  /// RSA_set0_key sets |rsa|'s modulus, public exponent, and private exponent to
  /// |n|, |e|, and |d| respectively, if non-NULL. On success, it takes ownership
  /// of each argument and returns one. Otherwise, it returns zero.
  ///
  /// |d| may be NULL, but |n| and |e| must either be non-NULL or already
  /// configured on |rsa|.
  ///
  /// It is an error to call this function after |rsa| has been used for a
  /// cryptographic operation. Construct a new |RSA| object instead.
  int RSA_set0_key(
    ffi.Pointer<RSA> rsa,
    ffi.Pointer<BIGNUM> n,
    ffi.Pointer<BIGNUM> e,
    ffi.Pointer<BIGNUM> d,
  ) {
    return _RSA_set0_key(
      rsa,
      n,
      e,
      d,
    );
  }

  late final _RSA_set0_key_ptr =
      _lookup<ffi.NativeFunction<_c_RSA_set0_key>>('RSA_set0_key');
  late final _dart_RSA_set0_key _RSA_set0_key =
      _RSA_set0_key_ptr.asFunction<_dart_RSA_set0_key>();

  late final ffi.Pointer<ASN1_ITEM_st> _SXNETID_it =
      _lookup<ASN1_ITEM_st>('SXNETID_it');

  ffi.Pointer<ASN1_ITEM_st> get SXNETID_it => _SXNETID_it;

  late final ffi.Pointer<ASN1_ITEM_st> _SXNET_it =
      _lookup<ASN1_ITEM_st>('SXNET_it');

  ffi.Pointer<ASN1_ITEM_st> get SXNET_it => _SXNET_it;

  late final ffi.Pointer<ASN1_ITEM_st> _USERNOTICE_it =
      _lookup<ASN1_ITEM_st>('USERNOTICE_it');

  ffi.Pointer<ASN1_ITEM_st> get USERNOTICE_it => _USERNOTICE_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_ALGORS_it =
      _lookup<ASN1_ITEM_st>('X509_ALGORS_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_ALGORS_it => _X509_ALGORS_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_ALGOR_it =
      _lookup<ASN1_ITEM_st>('X509_ALGOR_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_ALGOR_it => _X509_ALGOR_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_ATTRIBUTE_it =
      _lookup<ASN1_ITEM_st>('X509_ATTRIBUTE_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_ATTRIBUTE_it => _X509_ATTRIBUTE_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_CERT_AUX_it =
      _lookup<ASN1_ITEM_st>('X509_CERT_AUX_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_CERT_AUX_it => _X509_CERT_AUX_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_CINF_it =
      _lookup<ASN1_ITEM_st>('X509_CINF_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_CINF_it => _X509_CINF_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_CRL_INFO_it =
      _lookup<ASN1_ITEM_st>('X509_CRL_INFO_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_CRL_INFO_it => _X509_CRL_INFO_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_CRL_it =
      _lookup<ASN1_ITEM_st>('X509_CRL_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_CRL_it => _X509_CRL_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_EXTENSIONS_it =
      _lookup<ASN1_ITEM_st>('X509_EXTENSIONS_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_EXTENSIONS_it => _X509_EXTENSIONS_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_EXTENSION_it =
      _lookup<ASN1_ITEM_st>('X509_EXTENSION_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_EXTENSION_it => _X509_EXTENSION_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_NAME_ENTRY_it =
      _lookup<ASN1_ITEM_st>('X509_NAME_ENTRY_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_NAME_ENTRY_it => _X509_NAME_ENTRY_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_NAME_it =
      _lookup<ASN1_ITEM_st>('X509_NAME_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_NAME_it => _X509_NAME_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_PUBKEY_it =
      _lookup<ASN1_ITEM_st>('X509_PUBKEY_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_PUBKEY_it => _X509_PUBKEY_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_REQ_INFO_it =
      _lookup<ASN1_ITEM_st>('X509_REQ_INFO_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_REQ_INFO_it => _X509_REQ_INFO_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_REQ_it =
      _lookup<ASN1_ITEM_st>('X509_REQ_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_REQ_it => _X509_REQ_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_REVOKED_it =
      _lookup<ASN1_ITEM_st>('X509_REVOKED_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_REVOKED_it => _X509_REVOKED_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_SIG_it =
      _lookup<ASN1_ITEM_st>('X509_SIG_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_SIG_it => _X509_SIG_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_VAL_it =
      _lookup<ASN1_ITEM_st>('X509_VAL_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_VAL_it => _X509_VAL_it;

  late final ffi.Pointer<ASN1_ITEM_st> _X509_it =
      _lookup<ASN1_ITEM_st>('X509_it');

  ffi.Pointer<ASN1_ITEM_st> get X509_it => _X509_it;

  late final ffi.Pointer<ffi.Int32> ___mb_cur_max =
      _lookup<ffi.Int32>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stderrp =
      _lookup<ffi.Pointer<FILE>>('__stderrp');

  ffi.Pointer<FILE> get __stderrp => ___stderrp.value;

  set __stderrp(ffi.Pointer<FILE> value) => ___stderrp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdinp =
      _lookup<ffi.Pointer<FILE>>('__stdinp');

  ffi.Pointer<FILE> get __stdinp => ___stdinp.value;

  set __stdinp(ffi.Pointer<FILE> value) => ___stdinp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdoutp =
      _lookup<ffi.Pointer<FILE>>('__stdoutp');

  ffi.Pointer<FILE> get __stdoutp => ___stdoutp.value;

  set __stdoutp(ffi.Pointer<FILE> value) => ___stdoutp.value = value;

  late final ffi.Pointer<ffi.Int32> _daylight = _lookup<ffi.Int32>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  late final ffi.Pointer<ffi.Int32> _getdate_err =
      _lookup<ffi.Int32>('getdate_err');

  int get getdate_err => _getdate_err.value;

  set getdate_err(int value) => _getdate_err.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Int8>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Int8>>('suboptarg');

  ffi.Pointer<ffi.Int8> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Int8> value) => _suboptarg.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> _sys_errlist =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int8>>>('sys_errlist');

  ffi.Pointer<ffi.Pointer<ffi.Int8>> get sys_errlist => _sys_errlist.value;

  set sys_errlist(ffi.Pointer<ffi.Pointer<ffi.Int8>> value) =>
      _sys_errlist.value = value;

  late final ffi.Pointer<ffi.Int32> _sys_nerr = _lookup<ffi.Int32>('sys_nerr');

  int get sys_nerr => _sys_nerr.value;

  set sys_nerr(int value) => _sys_nerr.value = value;

  late final ffi.Pointer<ffi.Int64> _timezone = _lookup<ffi.Int64>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int8>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Int8>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Int8>> value) => _tzname.value = value;

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final BoringSsl _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<Native_EVP_PKEY_free>> get EVP_PKEY_free =>
      _library._EVP_PKEY_free_ptr;
}

const int AES_BLOCK_SIZE = 16;

class ASN1_ITEM_st extends ffi.Opaque {}

/// Private functions
class BIGNUM extends ffi.Struct {
  /// d is a pointer to an array of |width| |BN_BITS2|-bit chunks in
  /// little-endian order. This stores the absolute value of the number.
  external ffi.Pointer<ffi.Uint64> d;

  /// width is the number of elements of |d| which are valid. This value is not
  /// necessarily minimal; the most-significant words of |d| may be zero.
  /// |width| determines a potentially loose upper-bound on the absolute value
  /// of the |BIGNUM|.
  ///
  /// Functions taking |BIGNUM| inputs must compute the same answer for all
  /// possible widths. |bn_minimal_width|, |bn_set_minimal_width|, and other
  /// helpers may be used to recover the minimal width, provided it is not
  /// secret. If it is secret, use a different algorithm. Functions may output
  /// minimal or non-minimal |BIGNUM|s depending on secrecy requirements, but
  /// those which cause widths to unboundedly grow beyond the minimal value
  /// should be documented such.
  ///
  /// Note this is different from historical |BIGNUM| semantics.
  @ffi.Int32()
  external int width;

  /// dmax is number of elements of |d| which are allocated.
  @ffi.Int32()
  external int dmax;

  /// neg is one if the number if negative and zero otherwise.
  @ffi.Int32()
  external int neg;

  /// flags is a bitmask of |BN_FLG_*| values
  @ffi.Int32()
  external int flags;
}

class BN_BLINDING extends ffi.Opaque {}

class BN_CTX extends ffi.Opaque {}

/// bn_gencb_st, or |BN_GENCB|, holds a callback function that is used by
/// generation functions that can take a very long time to complete. Use
/// |BN_GENCB_set| to initialise a |BN_GENCB| structure.
///
/// The callback receives the address of that |BN_GENCB| structure as its last
/// argument and the user is free to put an arbitrary pointer in |arg|. The other
/// arguments are set as follows:
/// event=BN_GENCB_GENERATED, n=i:   after generating the i'th possible prime
/// number.
/// event=BN_GENCB_PRIME_TEST, n=-1: when finished trial division primality
/// checks.
/// event=BN_GENCB_PRIME_TEST, n=i:  when the i'th primality test has finished.
///
/// The callback can return zero to abort the generation progress or one to
/// allow it to continue.
///
/// When other code needs to call a BN generation function it will often take a
/// BN_GENCB argument and may call the function with other argument values.
class BN_GENCB extends ffi.Opaque {}

class BN_MONT_CTX extends ffi.Opaque {}

class CBB extends ffi.Struct {
  external ffi.Pointer<cbb_buffer_st> base;

  /// child points to a child CBB if a length-prefix is pending.
  external ffi.Pointer<CBB> child;

  /// offset is the number of bytes from the start of |base->buf| to this |CBB|'s
  /// pending length prefix.
  @ffi.IntPtr()
  external int offset;

  /// pending_len_len contains the number of bytes in this |CBB|'s pending
  /// length-prefix, or zero if no length-prefix is pending.
  @ffi.Uint8()
  external int pending_len_len;

  @ffi.Int8()
  external int pending_is_asn1;

  /// is_child is true iff this is a child |CBB| (as opposed to a top-level
  /// |CBB|). Top-level objects are valid arguments for |CBB_finish|.
  @ffi.Int8()
  external int is_child;
}

/// CRYPTO ByteString
class CBS extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.IntPtr()
  external int len;
}

class CRYPTO_EX_DATA extends ffi.Struct {
  external ffi.Pointer<stack_st_void> sk;
}

/// Low-level signing and verification.
///
/// Low-level functions handle signatures as |ECDSA_SIG| structures which allow
/// the two values in an ECDSA signature to be handled separately.
class ECDSA_SIG extends ffi.Opaque {}

class EC_GROUP extends ffi.Opaque {}

class EC_KEY extends ffi.Opaque {}

const int EC_PKEY_NO_PUBKEY = 2;

class EC_POINT extends ffi.Opaque {}

class ENGINE extends ffi.Opaque {}

const int ERR_LIB_HKDF = 31;

class EVP_AEAD extends ffi.Opaque {}

/// An EVP_AEAD_CTX represents an AEAD algorithm configured with a specific key
/// and message-independent IV.
class EVP_AEAD_CTX extends ffi.Opaque {}

class EVP_CIPHER extends ffi.Struct {
  /// type contains a NID identifing the cipher. (e.g. NID_aes_128_gcm.)
  @ffi.Int32()
  external int nid;

  /// block_size contains the block size, in bytes, of the cipher, or 1 for a
  /// stream cipher.
  @ffi.Uint32()
  external int block_size;

  /// key_len contains the key size, in bytes, for the cipher. If the cipher
  /// takes a variable key size then this contains the default size.
  @ffi.Uint32()
  external int key_len;

  /// iv_len contains the IV size, in bytes, or zero if inapplicable.
  @ffi.Uint32()
  external int iv_len;

  /// ctx_size contains the size, in bytes, of the per-key context for this
  /// cipher.
  @ffi.Uint32()
  external int ctx_size;

  /// flags contains the OR of a number of flags. See |EVP_CIPH_*|.
  @ffi.Uint32()
  external int flags;

  /// app_data is a pointer to opaque, user data.
  external ffi.Pointer<ffi.Void> app_data;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> init;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> cipher;

  /// cleanup, if non-NULL, releases memory associated with the context. It is
  /// called if |EVP_CTRL_INIT| succeeds. Note that |init| may not have been
  /// called at this point.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> cleanup;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_4>> ctrl;
}

class EVP_CIPHER_CTX extends ffi.Opaque {}

class EVP_MD extends ffi.Opaque {}

class EVP_MD_CTX extends ffi.Struct {
  /// digest is the underlying digest function, or NULL if not set.
  external ffi.Pointer<EVP_MD> digest;

  /// md_data points to a block of memory that contains the hash-specific
  /// context.
  external ffi.Pointer<ffi.Void> md_data;

  /// pctx is an opaque (at this layer) pointer to additional context that
  /// EVP_PKEY functions may store in this object.
  external ffi.Pointer<EVP_PKEY_CTX> pctx;

  /// pctx_ops, if not NULL, points to a vtable that contains functions to
  /// manipulate |pctx|.
  external ffi.Pointer<evp_md_pctx_ops> pctx_ops;
}

/// Private structures.
class EVP_PKEY extends ffi.Opaque {}

class EVP_PKEY_ASN1_METHOD extends ffi.Opaque {}

class EVP_PKEY_CTX extends ffi.Opaque {}

const int EVP_PKEY_EC = 408;

const int EVP_PKEY_RSA = 6;

class FILE extends ffi.Opaque {}

const int HKDF_R_OUTPUT_TOO_LARGE = 100;

/// Private functions
class HMAC_CTX extends ffi.Struct {
  external ffi.Pointer<EVP_MD> md;

  external EVP_MD_CTX md_ctx;

  external EVP_MD_CTX i_ctx;

  external EVP_MD_CTX o_ctx;
}

const int NID_X9_62_prime256v1 = 415;

const int NID_secp384r1 = 715;

const int NID_secp521r1 = 716;

class RSA extends ffi.Opaque {}

class RSA_METHOD extends ffi.Opaque {}

const int RSA_PKCS1_OAEP_PADDING = 4;

const int RSA_PKCS1_PADDING = 1;

const int RSA_PKCS1_PSS_PADDING = 6;

class __sFILEX extends ffi.Opaque {}

class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> _base;

  @ffi.Int32()
  external int _size;
}

class _opaque_pthread_rwlock_t extends ffi.Opaque {}

/// CRYPTO ByteBuilder.
///
/// |CBB| objects allow one to build length-prefixed serialisations. A |CBB|
/// object is associated with a buffer and new buffers are created with
/// |CBB_init|. Several |CBB| objects can point at the same buffer when a
/// length-prefix is pending, however only a single |CBB| can be 'current' at
/// any one time. For example, if one calls |CBB_add_u8_length_prefixed| then
/// the new |CBB| points at the same buffer as the original. But if the original
/// |CBB| is used then the length prefix is written out and the new |CBB| must
/// not be used again.
///
/// If one needs to force a length prefix to be written out because a |CBB| is
/// going out of scope, use |CBB_flush|. If an operation on a |CBB| fails, it is
/// in an undefined state and must not be used except to call |CBB_cleanup|.
class cbb_buffer_st extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> buf;

  /// The number of valid bytes.
  @ffi.IntPtr()
  external int len;

  /// The size of buf.
  @ffi.IntPtr()
  external int cap;

  /// One iff |buf| is owned by this object. If not then |buf|
  /// cannot be resized.
  @ffi.Int8()
  external int can_resize;

  /// One iff there was an error writing to this CBB. All future
  /// operations will fail.
  @ffi.Int8()
  external int error;
}

class evp_md_pctx_ops extends ffi.Opaque {}

/// point_conversion_form_t enumerates forms, as defined in X9.62 (ECDSA), for
/// the encoding of a elliptic curve point (x,y)
abstract class point_conversion_form_t {
  /// POINT_CONVERSION_COMPRESSED indicates that the point is encoded as z||x,
  /// where the octet z specifies which solution of the quadratic equation y
  /// is.
  static const int POINT_CONVERSION_COMPRESSED = 2;

  /// POINT_CONVERSION_UNCOMPRESSED indicates that the point is encoded as
  /// z||x||y, where z is the octet 0x04.
  static const int POINT_CONVERSION_UNCOMPRESSED = 4;

  /// POINT_CONVERSION_HYBRID indicates that the point is encoded as z||x||y,
  /// where z specifies which solution of the quadratic equation y is. This is
  /// not supported by the code and has never been observed in use.
  ///
  /// TODO(agl): remove once node.js no longer references this.
  static const int POINT_CONVERSION_HYBRID = 6;
}

class stack_st_void extends ffi.Opaque {}

typedef _c_BN_add = ffi.Int32 Function(
  ffi.Pointer<BIGNUM> r,
  ffi.Pointer<BIGNUM> a,
  ffi.Pointer<BIGNUM> b,
);

typedef _dart_BN_add = int Function(
  ffi.Pointer<BIGNUM> r,
  ffi.Pointer<BIGNUM> a,
  ffi.Pointer<BIGNUM> b,
);

typedef _c_BN_bin2bn = ffi.Pointer<BIGNUM> Function(
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.IntPtr len,
  ffi.Pointer<BIGNUM> ret,
);

typedef _dart_BN_bin2bn = ffi.Pointer<BIGNUM> Function(
  ffi.Pointer<ffi.Uint8> in_1,
  int len,
  ffi.Pointer<BIGNUM> ret,
);

typedef _c_BN_bn2bin_padded = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.IntPtr len,
  ffi.Pointer<BIGNUM> in_1,
);

typedef _dart_BN_bn2bin_padded = int Function(
  ffi.Pointer<ffi.Uint8> out,
  int len,
  ffi.Pointer<BIGNUM> in_1,
);

typedef _c_BN_cmp = ffi.Int32 Function(
  ffi.Pointer<BIGNUM> a,
  ffi.Pointer<BIGNUM> b,
);

typedef _dart_BN_cmp = int Function(
  ffi.Pointer<BIGNUM> a,
  ffi.Pointer<BIGNUM> b,
);

typedef _c_BN_free = ffi.Void Function(
  ffi.Pointer<BIGNUM> bn,
);

typedef _dart_BN_free = void Function(
  ffi.Pointer<BIGNUM> bn,
);

typedef _c_BN_lshift = ffi.Int32 Function(
  ffi.Pointer<BIGNUM> r,
  ffi.Pointer<BIGNUM> a,
  ffi.Int32 n,
);

typedef _dart_BN_lshift = int Function(
  ffi.Pointer<BIGNUM> r,
  ffi.Pointer<BIGNUM> a,
  int n,
);

typedef _c_BN_new = ffi.Pointer<BIGNUM> Function();

typedef _dart_BN_new = ffi.Pointer<BIGNUM> Function();

typedef _c_BN_num_bytes = ffi.Uint32 Function(
  ffi.Pointer<BIGNUM> bn,
);

typedef _dart_BN_num_bytes = int Function(
  ffi.Pointer<BIGNUM> bn,
);

typedef _c_BN_set_word = ffi.Int32 Function(
  ffi.Pointer<BIGNUM> bn,
  ffi.Uint64 value,
);

typedef _dart_BN_set_word = int Function(
  ffi.Pointer<BIGNUM> bn,
  int value,
);

typedef _c_BN_sub = ffi.Int32 Function(
  ffi.Pointer<BIGNUM> r,
  ffi.Pointer<BIGNUM> a,
  ffi.Pointer<BIGNUM> b,
);

typedef _dart_BN_sub = int Function(
  ffi.Pointer<BIGNUM> r,
  ffi.Pointer<BIGNUM> a,
  ffi.Pointer<BIGNUM> b,
);

typedef _c_BN_value_one = ffi.Pointer<BIGNUM> Function();

typedef _dart_BN_value_one = ffi.Pointer<BIGNUM> Function();

typedef _c_BORINGSSL_self_test = ffi.Int32 Function();

typedef _dart_BORINGSSL_self_test = int Function();

typedef _c_CBB_cleanup = ffi.Void Function(
  ffi.Pointer<CBB> cbb,
);

typedef _dart_CBB_cleanup = void Function(
  ffi.Pointer<CBB> cbb,
);

typedef _c_CBB_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<CBB> cbb,
);

typedef _dart_CBB_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<CBB> cbb,
);

typedef _c_CBB_flush = ffi.Int32 Function(
  ffi.Pointer<CBB> cbb,
);

typedef _dart_CBB_flush = int Function(
  ffi.Pointer<CBB> cbb,
);

typedef _c_CBB_init = ffi.Int32 Function(
  ffi.Pointer<CBB> cbb,
  ffi.IntPtr initial_capacity,
);

typedef _dart_CBB_init = int Function(
  ffi.Pointer<CBB> cbb,
  int initial_capacity,
);

typedef _c_CBB_len = ffi.IntPtr Function(
  ffi.Pointer<CBB> cbb,
);

typedef _dart_CBB_len = int Function(
  ffi.Pointer<CBB> cbb,
);

typedef _c_CBB_zero = ffi.Void Function(
  ffi.Pointer<CBB> cbb,
);

typedef _dart_CBB_zero = void Function(
  ffi.Pointer<CBB> cbb,
);

typedef _c_CBS_init = ffi.Void Function(
  ffi.Pointer<CBS> cbs,
  ffi.Pointer<ffi.Uint8> data,
  ffi.IntPtr len,
);

typedef _dart_CBS_init = void Function(
  ffi.Pointer<CBS> cbs,
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_CRYPTO_memcmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> a,
  ffi.Pointer<ffi.Void> b,
  ffi.IntPtr len,
);

typedef _dart_CRYPTO_memcmp = int Function(
  ffi.Pointer<ffi.Void> a,
  ffi.Pointer<ffi.Void> b,
  int len,
);

typedef _typedefC_5 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.IntPtr>,
);

typedef _c_ECDH_compute_key = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> out,
  ffi.IntPtr outlen,
  ffi.Pointer<EC_POINT> pub_key,
  ffi.Pointer<EC_KEY> priv_key,
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> kdf,
);

typedef _dart_ECDH_compute_key = int Function(
  ffi.Pointer<ffi.Void> out,
  int outlen,
  ffi.Pointer<EC_POINT> pub_key,
  ffi.Pointer<EC_KEY> priv_key,
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> kdf,
);

typedef _c_ECDSA_SIG_free = ffi.Void Function(
  ffi.Pointer<ECDSA_SIG> sig,
);

typedef _dart_ECDSA_SIG_free = void Function(
  ffi.Pointer<ECDSA_SIG> sig,
);

typedef _c_ECDSA_SIG_get0 = ffi.Void Function(
  ffi.Pointer<ECDSA_SIG> sig,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_r,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_s,
);

typedef _dart_ECDSA_SIG_get0 = void Function(
  ffi.Pointer<ECDSA_SIG> sig,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_r,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_s,
);

typedef _c_ECDSA_SIG_marshal = ffi.Int32 Function(
  ffi.Pointer<CBB> cbb,
  ffi.Pointer<ECDSA_SIG> sig,
);

typedef _dart_ECDSA_SIG_marshal = int Function(
  ffi.Pointer<CBB> cbb,
  ffi.Pointer<ECDSA_SIG> sig,
);

typedef _c_ECDSA_SIG_new = ffi.Pointer<ECDSA_SIG> Function();

typedef _dart_ECDSA_SIG_new = ffi.Pointer<ECDSA_SIG> Function();

typedef _c_ECDSA_SIG_parse = ffi.Pointer<ECDSA_SIG> Function(
  ffi.Pointer<CBS> cbs,
);

typedef _dart_ECDSA_SIG_parse = ffi.Pointer<ECDSA_SIG> Function(
  ffi.Pointer<CBS> cbs,
);

typedef _c_EC_GROUP_free = ffi.Void Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _dart_EC_GROUP_free = void Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _c_EC_GROUP_get0_order = ffi.Pointer<BIGNUM> Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _dart_EC_GROUP_get0_order = ffi.Pointer<BIGNUM> Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _c_EC_GROUP_get_curve_name = ffi.Int32 Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _dart_EC_GROUP_get_curve_name = int Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _c_EC_GROUP_get_degree = ffi.Uint32 Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _dart_EC_GROUP_get_degree = int Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _c_EC_GROUP_new_by_curve_name = ffi.Pointer<EC_GROUP> Function(
  ffi.Int32 nid,
);

typedef _dart_EC_GROUP_new_by_curve_name = ffi.Pointer<EC_GROUP> Function(
  int nid,
);

typedef _c_EC_KEY_check_key = ffi.Int32 Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_check_key = int Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_free = ffi.Void Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_free = void Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_generate_key = ffi.Int32 Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_generate_key = int Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_get0_group = ffi.Pointer<EC_GROUP> Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_get0_group = ffi.Pointer<EC_GROUP> Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_get0_private_key = ffi.Pointer<BIGNUM> Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_get0_private_key = ffi.Pointer<BIGNUM> Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_get0_public_key = ffi.Pointer<EC_POINT> Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_get0_public_key = ffi.Pointer<EC_POINT> Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_get_enc_flags = ffi.Uint32 Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EC_KEY_get_enc_flags = int Function(
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EC_KEY_new_by_curve_name = ffi.Pointer<EC_KEY> Function(
  ffi.Int32 nid,
);

typedef _dart_EC_KEY_new_by_curve_name = ffi.Pointer<EC_KEY> Function(
  int nid,
);

typedef _c_EC_KEY_set_enc_flags = ffi.Void Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Uint32 flags,
);

typedef _dart_EC_KEY_set_enc_flags = void Function(
  ffi.Pointer<EC_KEY> key,
  int flags,
);

typedef _c_EC_KEY_set_private_key = ffi.Int32 Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Pointer<BIGNUM> priv,
);

typedef _dart_EC_KEY_set_private_key = int Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Pointer<BIGNUM> priv,
);

typedef _c_EC_KEY_set_public_key = ffi.Int32 Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Pointer<EC_POINT> pub,
);

typedef _dart_EC_KEY_set_public_key = int Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Pointer<EC_POINT> pub,
);

typedef _c_EC_KEY_set_public_key_affine_coordinates = ffi.Int32 Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Pointer<BIGNUM> x,
  ffi.Pointer<BIGNUM> y,
);

typedef _dart_EC_KEY_set_public_key_affine_coordinates = int Function(
  ffi.Pointer<EC_KEY> key,
  ffi.Pointer<BIGNUM> x,
  ffi.Pointer<BIGNUM> y,
);

typedef _c_EC_POINT_free = ffi.Void Function(
  ffi.Pointer<EC_POINT> point,
);

typedef _dart_EC_POINT_free = void Function(
  ffi.Pointer<EC_POINT> point,
);

typedef _c_EC_POINT_get_affine_coordinates_GFp = ffi.Int32 Function(
  ffi.Pointer<EC_GROUP> group,
  ffi.Pointer<EC_POINT> point,
  ffi.Pointer<BIGNUM> x,
  ffi.Pointer<BIGNUM> y,
  ffi.Pointer<BN_CTX> ctx,
);

typedef _dart_EC_POINT_get_affine_coordinates_GFp = int Function(
  ffi.Pointer<EC_GROUP> group,
  ffi.Pointer<EC_POINT> point,
  ffi.Pointer<BIGNUM> x,
  ffi.Pointer<BIGNUM> y,
  ffi.Pointer<BN_CTX> ctx,
);

typedef _c_EC_POINT_new = ffi.Pointer<EC_POINT> Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _dart_EC_POINT_new = ffi.Pointer<EC_POINT> Function(
  ffi.Pointer<EC_GROUP> group,
);

typedef _c_EC_POINT_oct2point = ffi.Int32 Function(
  ffi.Pointer<EC_GROUP> group,
  ffi.Pointer<EC_POINT> point,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.IntPtr len,
  ffi.Pointer<BN_CTX> ctx,
);

typedef _dart_EC_POINT_oct2point = int Function(
  ffi.Pointer<EC_GROUP> group,
  ffi.Pointer<EC_POINT> point,
  ffi.Pointer<ffi.Uint8> buf,
  int len,
  ffi.Pointer<BN_CTX> ctx,
);

typedef _c_EC_POINT_point2cbb = ffi.Int32 Function(
  ffi.Pointer<CBB> out,
  ffi.Pointer<EC_GROUP> group,
  ffi.Pointer<EC_POINT> point,
  ffi.Int32 form,
  ffi.Pointer<BN_CTX> ctx,
);

typedef _dart_EC_POINT_point2cbb = int Function(
  ffi.Pointer<CBB> out,
  ffi.Pointer<EC_GROUP> group,
  ffi.Pointer<EC_POINT> point,
  int form,
  ffi.Pointer<BN_CTX> ctx,
);

typedef _c_ERR_clear_error = ffi.Void Function();

typedef _dart_ERR_clear_error = void Function();

typedef _c_ERR_error_string_n = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint32 packed_error,
  ffi.Pointer<ffi.Int8> buf,
  ffi.IntPtr len,
);

typedef _dart_ERR_error_string_n = ffi.Pointer<ffi.Int8> Function(
  int packed_error,
  ffi.Pointer<ffi.Int8> buf,
  int len,
);

typedef _c_ERR_get_error = ffi.Uint32 Function();

typedef _dart_ERR_get_error = int Function();

typedef _c_ERR_peek_error = ffi.Uint32 Function();

typedef _dart_ERR_peek_error = int Function();

typedef _c_EVP_AEAD_CTX_free = ffi.Void Function(
  ffi.Pointer<EVP_AEAD_CTX> ctx,
);

typedef _dart_EVP_AEAD_CTX_free = void Function(
  ffi.Pointer<EVP_AEAD_CTX> ctx,
);

typedef _c_EVP_AEAD_CTX_new = ffi.Pointer<EVP_AEAD_CTX> Function(
  ffi.Pointer<EVP_AEAD> aead,
  ffi.Pointer<ffi.Uint8> key,
  ffi.IntPtr key_len,
  ffi.IntPtr tag_len,
);

typedef _dart_EVP_AEAD_CTX_new = ffi.Pointer<EVP_AEAD_CTX> Function(
  ffi.Pointer<EVP_AEAD> aead,
  ffi.Pointer<ffi.Uint8> key,
  int key_len,
  int tag_len,
);

typedef _c_EVP_AEAD_CTX_open = ffi.Int32 Function(
  ffi.Pointer<EVP_AEAD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  ffi.IntPtr max_out_len,
  ffi.Pointer<ffi.Uint8> nonce,
  ffi.IntPtr nonce_len,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.IntPtr in_len,
  ffi.Pointer<ffi.Uint8> ad,
  ffi.IntPtr ad_len,
);

typedef _dart_EVP_AEAD_CTX_open = int Function(
  ffi.Pointer<EVP_AEAD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  int max_out_len,
  ffi.Pointer<ffi.Uint8> nonce,
  int nonce_len,
  ffi.Pointer<ffi.Uint8> in_1,
  int in_len,
  ffi.Pointer<ffi.Uint8> ad,
  int ad_len,
);

typedef _c_EVP_AEAD_CTX_seal = ffi.Int32 Function(
  ffi.Pointer<EVP_AEAD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  ffi.IntPtr max_out_len,
  ffi.Pointer<ffi.Uint8> nonce,
  ffi.IntPtr nonce_len,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.IntPtr in_len,
  ffi.Pointer<ffi.Uint8> ad,
  ffi.IntPtr ad_len,
);

typedef _dart_EVP_AEAD_CTX_seal = int Function(
  ffi.Pointer<EVP_AEAD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  int max_out_len,
  ffi.Pointer<ffi.Uint8> nonce,
  int nonce_len,
  ffi.Pointer<ffi.Uint8> in_1,
  int in_len,
  ffi.Pointer<ffi.Uint8> ad,
  int ad_len,
);

typedef _c_EVP_AEAD_key_length = ffi.IntPtr Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _dart_EVP_AEAD_key_length = int Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _c_EVP_AEAD_max_overhead = ffi.IntPtr Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _dart_EVP_AEAD_max_overhead = int Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _c_EVP_AEAD_max_tag_len = ffi.IntPtr Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _dart_EVP_AEAD_max_tag_len = int Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _c_EVP_AEAD_nonce_length = ffi.IntPtr Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _dart_EVP_AEAD_nonce_length = int Function(
  ffi.Pointer<EVP_AEAD> aead,
);

typedef _c_EVP_CIPHER_CTX_free = ffi.Void Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
);

typedef _dart_EVP_CIPHER_CTX_free = void Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
);

typedef _c_EVP_CIPHER_CTX_new = ffi.Pointer<EVP_CIPHER_CTX> Function();

typedef _dart_EVP_CIPHER_CTX_new = ffi.Pointer<EVP_CIPHER_CTX> Function();

typedef _c_EVP_CIPHER_block_size = ffi.Uint32 Function(
  ffi.Pointer<EVP_CIPHER> cipher,
);

typedef _dart_EVP_CIPHER_block_size = int Function(
  ffi.Pointer<EVP_CIPHER> cipher,
);

typedef _c_EVP_CIPHER_iv_length = ffi.Uint32 Function(
  ffi.Pointer<EVP_CIPHER> cipher,
);

typedef _dart_EVP_CIPHER_iv_length = int Function(
  ffi.Pointer<EVP_CIPHER> cipher,
);

typedef _c_EVP_CipherFinal_ex = ffi.Int32 Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Int32> out_len,
);

typedef _dart_EVP_CipherFinal_ex = int Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Int32> out_len,
);

typedef _c_EVP_CipherInit_ex = ffi.Int32 Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ffi.Pointer<EVP_CIPHER> cipher,
  ffi.Pointer<ENGINE> engine,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 enc,
);

typedef _dart_EVP_CipherInit_ex = int Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ffi.Pointer<EVP_CIPHER> cipher,
  ffi.Pointer<ENGINE> engine,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Pointer<ffi.Uint8> iv,
  int enc,
);

typedef _c_EVP_CipherUpdate = ffi.Int32 Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Int32> out_len,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.Int32 in_len,
);

typedef _dart_EVP_CipherUpdate = int Function(
  ffi.Pointer<EVP_CIPHER_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Int32> out_len,
  ffi.Pointer<ffi.Uint8> in_1,
  int in_len,
);

typedef _c_EVP_DigestFinal = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> md_out,
  ffi.Pointer<ffi.Uint32> out_size,
);

typedef _dart_EVP_DigestFinal = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> md_out,
  ffi.Pointer<ffi.Uint32> out_size,
);

typedef _c_EVP_DigestInit = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<EVP_MD> type,
);

typedef _dart_EVP_DigestInit = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<EVP_MD> type,
);

typedef _c_EVP_DigestSignFinal = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out_sig,
  ffi.Pointer<ffi.IntPtr> out_sig_len,
);

typedef _dart_EVP_DigestSignFinal = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out_sig,
  ffi.Pointer<ffi.IntPtr> out_sig_len,
);

typedef _c_EVP_DigestSignInit = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Pointer<EVP_PKEY_CTX>> pctx,
  ffi.Pointer<EVP_MD> type,
  ffi.Pointer<ENGINE> e,
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _dart_EVP_DigestSignInit = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Pointer<EVP_PKEY_CTX>> pctx,
  ffi.Pointer<EVP_MD> type,
  ffi.Pointer<ENGINE> e,
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _c_EVP_DigestSignUpdate = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Void> data,
  ffi.IntPtr len,
);

typedef _dart_EVP_DigestSignUpdate = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Void> data,
  int len,
);

typedef _c_EVP_DigestUpdate = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Void> data,
  ffi.IntPtr len,
);

typedef _dart_EVP_DigestUpdate = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Void> data,
  int len,
);

typedef _c_EVP_DigestVerifyFinal = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> sig,
  ffi.IntPtr sig_len,
);

typedef _dart_EVP_DigestVerifyFinal = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Uint8> sig,
  int sig_len,
);

typedef _c_EVP_DigestVerifyInit = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Pointer<EVP_PKEY_CTX>> pctx,
  ffi.Pointer<EVP_MD> type,
  ffi.Pointer<ENGINE> e,
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _dart_EVP_DigestVerifyInit = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Pointer<EVP_PKEY_CTX>> pctx,
  ffi.Pointer<EVP_MD> type,
  ffi.Pointer<ENGINE> e,
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _c_EVP_DigestVerifyUpdate = ffi.Int32 Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Void> data,
  ffi.IntPtr len,
);

typedef _dart_EVP_DigestVerifyUpdate = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
  ffi.Pointer<ffi.Void> data,
  int len,
);

typedef _c_EVP_MD_CTX_free = ffi.Void Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
);

typedef _dart_EVP_MD_CTX_free = void Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
);

typedef _c_EVP_MD_CTX_new = ffi.Pointer<EVP_MD_CTX> Function();

typedef _dart_EVP_MD_CTX_new = ffi.Pointer<EVP_MD_CTX> Function();

typedef _c_EVP_MD_CTX_size = ffi.IntPtr Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
);

typedef _dart_EVP_MD_CTX_size = int Function(
  ffi.Pointer<EVP_MD_CTX> ctx,
);

typedef _c_EVP_MD_size = ffi.IntPtr Function(
  ffi.Pointer<EVP_MD> md,
);

typedef _dart_EVP_MD_size = int Function(
  ffi.Pointer<EVP_MD> md,
);

typedef _c_EVP_PKEY_CTX_free = ffi.Void Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
);

typedef _dart_EVP_PKEY_CTX_free = void Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
);

typedef _c_EVP_PKEY_CTX_new = ffi.Pointer<EVP_PKEY_CTX> Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Pointer<ENGINE> e,
);

typedef _dart_EVP_PKEY_CTX_new = ffi.Pointer<EVP_PKEY_CTX> Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Pointer<ENGINE> e,
);

typedef _c_EVP_PKEY_CTX_set0_rsa_oaep_label = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<ffi.Uint8> label,
  ffi.IntPtr label_len,
);

typedef _dart_EVP_PKEY_CTX_set0_rsa_oaep_label = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<ffi.Uint8> label,
  int label_len,
);

typedef _c_EVP_PKEY_CTX_set_rsa_mgf1_md = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<EVP_MD> md,
);

typedef _dart_EVP_PKEY_CTX_set_rsa_mgf1_md = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<EVP_MD> md,
);

typedef _c_EVP_PKEY_CTX_set_rsa_oaep_md = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<EVP_MD> md,
);

typedef _dart_EVP_PKEY_CTX_set_rsa_oaep_md = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<EVP_MD> md,
);

typedef _c_EVP_PKEY_CTX_set_rsa_padding = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Int32 padding,
);

typedef _dart_EVP_PKEY_CTX_set_rsa_padding = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  int padding,
);

typedef _c_EVP_PKEY_CTX_set_rsa_pss_saltlen = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Int32 salt_len,
);

typedef _dart_EVP_PKEY_CTX_set_rsa_pss_saltlen = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  int salt_len,
);

typedef _c_EVP_PKEY_decrypt = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.IntPtr in_len,
);

typedef _dart_EVP_PKEY_decrypt = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  ffi.Pointer<ffi.Uint8> in_1,
  int in_len,
);

typedef _c_EVP_PKEY_decrypt_init = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
);

typedef _dart_EVP_PKEY_decrypt_init = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
);

typedef _c_EVP_PKEY_encrypt = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.IntPtr in_len,
);

typedef _dart_EVP_PKEY_encrypt = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.IntPtr> out_len,
  ffi.Pointer<ffi.Uint8> in_1,
  int in_len,
);

typedef _c_EVP_PKEY_encrypt_init = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
);

typedef _dart_EVP_PKEY_encrypt_init = int Function(
  ffi.Pointer<EVP_PKEY_CTX> ctx,
);

typedef Native_EVP_PKEY_free = ffi.Void Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _dart_EVP_PKEY_free = void Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _c_EVP_PKEY_get1_EC_KEY = ffi.Pointer<EC_KEY> Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _dart_EVP_PKEY_get1_EC_KEY = ffi.Pointer<EC_KEY> Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _c_EVP_PKEY_get1_RSA = ffi.Pointer<RSA> Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _dart_EVP_PKEY_get1_RSA = ffi.Pointer<RSA> Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _c_EVP_PKEY_id = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _dart_EVP_PKEY_id = int Function(
  ffi.Pointer<EVP_PKEY> pkey,
);

typedef _c_EVP_PKEY_new = ffi.Pointer<EVP_PKEY> Function();

typedef _dart_EVP_PKEY_new = ffi.Pointer<EVP_PKEY> Function();

typedef _c_EVP_PKEY_set1_EC_KEY = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Pointer<EC_KEY> key,
);

typedef _dart_EVP_PKEY_set1_EC_KEY = int Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Pointer<EC_KEY> key,
);

typedef _c_EVP_PKEY_set1_RSA = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Pointer<RSA> key,
);

typedef _dart_EVP_PKEY_set1_RSA = int Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Pointer<RSA> key,
);

typedef _c_EVP_PKEY_set_type = ffi.Int32 Function(
  ffi.Pointer<EVP_PKEY> pkey,
  ffi.Int32 type,
);

typedef _dart_EVP_PKEY_set_type = int Function(
  ffi.Pointer<EVP_PKEY> pkey,
  int type,
);

typedef _c_EVP_aead_aes_128_gcm = ffi.Pointer<EVP_AEAD> Function();

typedef _dart_EVP_aead_aes_128_gcm = ffi.Pointer<EVP_AEAD> Function();

typedef _c_EVP_aead_aes_256_gcm = ffi.Pointer<EVP_AEAD> Function();

typedef _dart_EVP_aead_aes_256_gcm = ffi.Pointer<EVP_AEAD> Function();

typedef _c_EVP_aes_128_cbc = ffi.Pointer<EVP_CIPHER> Function();

typedef _dart_EVP_aes_128_cbc = ffi.Pointer<EVP_CIPHER> Function();

typedef _c_EVP_aes_128_ctr = ffi.Pointer<EVP_CIPHER> Function();

typedef _dart_EVP_aes_128_ctr = ffi.Pointer<EVP_CIPHER> Function();

typedef _c_EVP_aes_256_cbc = ffi.Pointer<EVP_CIPHER> Function();

typedef _dart_EVP_aes_256_cbc = ffi.Pointer<EVP_CIPHER> Function();

typedef _c_EVP_aes_256_ctr = ffi.Pointer<EVP_CIPHER> Function();

typedef _dart_EVP_aes_256_ctr = ffi.Pointer<EVP_CIPHER> Function();

typedef _c_EVP_marshal_private_key = ffi.Int32 Function(
  ffi.Pointer<CBB> cbb,
  ffi.Pointer<EVP_PKEY> key,
);

typedef _dart_EVP_marshal_private_key = int Function(
  ffi.Pointer<CBB> cbb,
  ffi.Pointer<EVP_PKEY> key,
);

typedef _c_EVP_marshal_public_key = ffi.Int32 Function(
  ffi.Pointer<CBB> cbb,
  ffi.Pointer<EVP_PKEY> key,
);

typedef _dart_EVP_marshal_public_key = int Function(
  ffi.Pointer<CBB> cbb,
  ffi.Pointer<EVP_PKEY> key,
);

typedef _c_EVP_parse_private_key = ffi.Pointer<EVP_PKEY> Function(
  ffi.Pointer<CBS> cbs,
);

typedef _dart_EVP_parse_private_key = ffi.Pointer<EVP_PKEY> Function(
  ffi.Pointer<CBS> cbs,
);

typedef _c_EVP_parse_public_key = ffi.Pointer<EVP_PKEY> Function(
  ffi.Pointer<CBS> cbs,
);

typedef _dart_EVP_parse_public_key = ffi.Pointer<EVP_PKEY> Function(
  ffi.Pointer<CBS> cbs,
);

typedef _c_EVP_sha1 = ffi.Pointer<EVP_MD> Function();

typedef _dart_EVP_sha1 = ffi.Pointer<EVP_MD> Function();

typedef _c_EVP_sha256 = ffi.Pointer<EVP_MD> Function();

typedef _dart_EVP_sha256 = ffi.Pointer<EVP_MD> Function();

typedef _c_EVP_sha384 = ffi.Pointer<EVP_MD> Function();

typedef _dart_EVP_sha384 = ffi.Pointer<EVP_MD> Function();

typedef _c_EVP_sha512 = ffi.Pointer<EVP_MD> Function();

typedef _dart_EVP_sha512 = ffi.Pointer<EVP_MD> Function();

typedef _c_HKDF = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> out_key,
  ffi.IntPtr out_len,
  ffi.Pointer<EVP_MD> digest,
  ffi.Pointer<ffi.Uint8> secret,
  ffi.IntPtr secret_len,
  ffi.Pointer<ffi.Uint8> salt,
  ffi.IntPtr salt_len,
  ffi.Pointer<ffi.Uint8> info,
  ffi.IntPtr info_len,
);

typedef _dart_HKDF = int Function(
  ffi.Pointer<ffi.Uint8> out_key,
  int out_len,
  ffi.Pointer<EVP_MD> digest,
  ffi.Pointer<ffi.Uint8> secret,
  int secret_len,
  ffi.Pointer<ffi.Uint8> salt,
  int salt_len,
  ffi.Pointer<ffi.Uint8> info,
  int info_len,
);

typedef _c_HMAC_CTX_free = ffi.Void Function(
  ffi.Pointer<HMAC_CTX> ctx,
);

typedef _dart_HMAC_CTX_free = void Function(
  ffi.Pointer<HMAC_CTX> ctx,
);

typedef _c_HMAC_CTX_new = ffi.Pointer<HMAC_CTX> Function();

typedef _dart_HMAC_CTX_new = ffi.Pointer<HMAC_CTX> Function();

typedef _c_HMAC_Final = ffi.Int32 Function(
  ffi.Pointer<HMAC_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint32> out_len,
);

typedef _dart_HMAC_Final = int Function(
  ffi.Pointer<HMAC_CTX> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint32> out_len,
);

typedef _c_HMAC_Init_ex = ffi.Int32 Function(
  ffi.Pointer<HMAC_CTX> ctx,
  ffi.Pointer<ffi.Void> key,
  ffi.IntPtr key_len,
  ffi.Pointer<EVP_MD> md,
  ffi.Pointer<ENGINE> impl,
);

typedef _dart_HMAC_Init_ex = int Function(
  ffi.Pointer<HMAC_CTX> ctx,
  ffi.Pointer<ffi.Void> key,
  int key_len,
  ffi.Pointer<EVP_MD> md,
  ffi.Pointer<ENGINE> impl,
);

typedef _c_HMAC_Update = ffi.Int32 Function(
  ffi.Pointer<HMAC_CTX> ctx,
  ffi.Pointer<ffi.Uint8> data,
  ffi.IntPtr data_len,
);

typedef _dart_HMAC_Update = int Function(
  ffi.Pointer<HMAC_CTX> ctx,
  ffi.Pointer<ffi.Uint8> data,
  int data_len,
);

typedef _c_HMAC_size = ffi.IntPtr Function(
  ffi.Pointer<HMAC_CTX> ctx,
);

typedef _dart_HMAC_size = int Function(
  ffi.Pointer<HMAC_CTX> ctx,
);

typedef _c_OPENSSL_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_OPENSSL_free = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_OPENSSL_malloc = ffi.Pointer<ffi.Void> Function(
  ffi.IntPtr size,
);

typedef _dart_OPENSSL_malloc = ffi.Pointer<ffi.Void> Function(
  int size,
);

typedef _c_OPENSSL_memdup = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> data,
  ffi.IntPtr size,
);

typedef _dart_OPENSSL_memdup = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> data,
  int size,
);

typedef _c_PKCS5_PBKDF2_HMAC = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> password,
  ffi.IntPtr password_len,
  ffi.Pointer<ffi.Uint8> salt,
  ffi.IntPtr salt_len,
  ffi.Uint32 iterations,
  ffi.Pointer<EVP_MD> digest,
  ffi.IntPtr key_len,
  ffi.Pointer<ffi.Uint8> out_key,
);

typedef _dart_PKCS5_PBKDF2_HMAC = int Function(
  ffi.Pointer<ffi.Int8> password,
  int password_len,
  ffi.Pointer<ffi.Uint8> salt,
  int salt_len,
  int iterations,
  ffi.Pointer<EVP_MD> digest,
  int key_len,
  ffi.Pointer<ffi.Uint8> out_key,
);

typedef _c_RAND_bytes = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> buf,
  ffi.IntPtr len,
);

typedef _dart_RAND_bytes = int Function(
  ffi.Pointer<ffi.Uint8> buf,
  int len,
);

typedef _c_RSAPublicKey_dup = ffi.Pointer<RSA> Function(
  ffi.Pointer<RSA> rsa,
);

typedef _dart_RSAPublicKey_dup = ffi.Pointer<RSA> Function(
  ffi.Pointer<RSA> rsa,
);

typedef _c_RSA_check_key = ffi.Int32 Function(
  ffi.Pointer<RSA> rsa,
);

typedef _dart_RSA_check_key = int Function(
  ffi.Pointer<RSA> rsa,
);

typedef _c_RSA_free = ffi.Void Function(
  ffi.Pointer<RSA> rsa,
);

typedef _dart_RSA_free = void Function(
  ffi.Pointer<RSA> rsa,
);

typedef _c_RSA_generate_key_ex = ffi.Int32 Function(
  ffi.Pointer<RSA> rsa,
  ffi.Int32 bits,
  ffi.Pointer<BIGNUM> e,
  ffi.Pointer<BN_GENCB> cb,
);

typedef _dart_RSA_generate_key_ex = int Function(
  ffi.Pointer<RSA> rsa,
  int bits,
  ffi.Pointer<BIGNUM> e,
  ffi.Pointer<BN_GENCB> cb,
);

typedef _c_RSA_get0_crt_params = ffi.Void Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_dmp1,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_dmq1,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_iqmp,
);

typedef _dart_RSA_get0_crt_params = void Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_dmp1,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_dmq1,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_iqmp,
);

typedef _c_RSA_get0_factors = ffi.Void Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_p,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_q,
);

typedef _dart_RSA_get0_factors = void Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_p,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_q,
);

typedef _c_RSA_get0_key = ffi.Void Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_n,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_e,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_d,
);

typedef _dart_RSA_get0_key = void Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_n,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_e,
  ffi.Pointer<ffi.Pointer<BIGNUM>> out_d,
);

typedef _c_RSA_new = ffi.Pointer<RSA> Function();

typedef _dart_RSA_new = ffi.Pointer<RSA> Function();

typedef _c_RSA_set0_crt_params = ffi.Int32 Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<BIGNUM> dmp1,
  ffi.Pointer<BIGNUM> dmq1,
  ffi.Pointer<BIGNUM> iqmp,
);

typedef _dart_RSA_set0_crt_params = int Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<BIGNUM> dmp1,
  ffi.Pointer<BIGNUM> dmq1,
  ffi.Pointer<BIGNUM> iqmp,
);

typedef _c_RSA_set0_factors = ffi.Int32 Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<BIGNUM> p,
  ffi.Pointer<BIGNUM> q,
);

typedef _dart_RSA_set0_factors = int Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<BIGNUM> p,
  ffi.Pointer<BIGNUM> q,
);

typedef _c_RSA_set0_key = ffi.Int32 Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<BIGNUM> n,
  ffi.Pointer<BIGNUM> e,
  ffi.Pointer<BIGNUM> d,
);

typedef _dart_RSA_set0_key = int Function(
  ffi.Pointer<RSA> rsa,
  ffi.Pointer<BIGNUM> n,
  ffi.Pointer<BIGNUM> e,
  ffi.Pointer<BIGNUM> d,
);

typedef _typedefC_1 = ffi.Int32 Function(
  ffi.Pointer<EVP_CIPHER_CTX>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_2 = ffi.Int32 Function(
  ffi.Pointer<EVP_CIPHER_CTX>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Pointer<ffi.Uint8>,
  ffi.IntPtr,
);

typedef _typedefC_3 = ffi.Void Function(
  ffi.Pointer<EVP_CIPHER_CTX>,
);

typedef _typedefC_4 = ffi.Int32 Function(
  ffi.Pointer<EVP_CIPHER_CTX>,
  ffi.Int32,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);
